(function webpackUniversalModuleDefinition(root, factory) {
	if(typeof exports === 'object' && typeof module === 'object')
		module.exports = factory(require("d3"));
	else if(typeof define === 'function' && define.amd)
		define(["d3"], factory);
	else if(typeof exports === 'object')
		exports["SimpleGraph"] = factory(require("d3"));
	else
		root["SimpleGraph"] = factory(root["d3"]);
})(window, function(__WEBPACK_EXTERNAL_MODULE__0__) {
return /******/ (function(modules) { // webpackBootstrap
/******/ 	// The module cache
/******/ 	var installedModules = {};
/******/
/******/ 	// The require function
/******/ 	function __webpack_require__(moduleId) {
/******/
/******/ 		// Check if module is in cache
/******/ 		if(installedModules[moduleId]) {
/******/ 			return installedModules[moduleId].exports;
/******/ 		}
/******/ 		// Create a new module (and put it into the cache)
/******/ 		var module = installedModules[moduleId] = {
/******/ 			i: moduleId,
/******/ 			l: false,
/******/ 			exports: {}
/******/ 		};
/******/
/******/ 		// Execute the module function
/******/ 		modules[moduleId].call(module.exports, module, module.exports, __webpack_require__);
/******/
/******/ 		// Flag the module as loaded
/******/ 		module.l = true;
/******/
/******/ 		// Return the exports of the module
/******/ 		return module.exports;
/******/ 	}
/******/
/******/
/******/ 	// expose the modules object (__webpack_modules__)
/******/ 	__webpack_require__.m = modules;
/******/
/******/ 	// expose the module cache
/******/ 	__webpack_require__.c = installedModules;
/******/
/******/ 	// define getter function for harmony exports
/******/ 	__webpack_require__.d = function(exports, name, getter) {
/******/ 		if(!__webpack_require__.o(exports, name)) {
/******/ 			Object.defineProperty(exports, name, { enumerable: true, get: getter });
/******/ 		}
/******/ 	};
/******/
/******/ 	// define __esModule on exports
/******/ 	__webpack_require__.r = function(exports) {
/******/ 		if(typeof Symbol !== 'undefined' && Symbol.toStringTag) {
/******/ 			Object.defineProperty(exports, Symbol.toStringTag, { value: 'Module' });
/******/ 		}
/******/ 		Object.defineProperty(exports, '__esModule', { value: true });
/******/ 	};
/******/
/******/ 	// create a fake namespace object
/******/ 	// mode & 1: value is a module id, require it
/******/ 	// mode & 2: merge all properties of value into the ns
/******/ 	// mode & 4: return value when already ns object
/******/ 	// mode & 8|1: behave like require
/******/ 	__webpack_require__.t = function(value, mode) {
/******/ 		if(mode & 1) value = __webpack_require__(value);
/******/ 		if(mode & 8) return value;
/******/ 		if((mode & 4) && typeof value === 'object' && value && value.__esModule) return value;
/******/ 		var ns = Object.create(null);
/******/ 		__webpack_require__.r(ns);
/******/ 		Object.defineProperty(ns, 'default', { enumerable: true, value: value });
/******/ 		if(mode & 2 && typeof value != 'string') for(var key in value) __webpack_require__.d(ns, key, function(key) { return value[key]; }.bind(null, key));
/******/ 		return ns;
/******/ 	};
/******/
/******/ 	// getDefaultExport function for compatibility with non-harmony modules
/******/ 	__webpack_require__.n = function(module) {
/******/ 		var getter = module && module.__esModule ?
/******/ 			function getDefault() { return module['default']; } :
/******/ 			function getModuleExports() { return module; };
/******/ 		__webpack_require__.d(getter, 'a', getter);
/******/ 		return getter;
/******/ 	};
/******/
/******/ 	// Object.prototype.hasOwnProperty.call
/******/ 	__webpack_require__.o = function(object, property) { return Object.prototype.hasOwnProperty.call(object, property); };
/******/
/******/ 	// __webpack_public_path__
/******/ 	__webpack_require__.p = "";
/******/
/******/
/******/ 	// Load entry module and return exports
/******/ 	return __webpack_require__(__webpack_require__.s = 1);
/******/ })
/************************************************************************/
/******/ ([
/* 0 */
/***/ (function(module, exports) {

module.exports = __WEBPACK_EXTERNAL_MODULE__0__;

/***/ }),
/* 1 */
/***/ (function(module, __webpack_exports__, __webpack_require__) {

"use strict";
// ESM COMPAT FLAG
__webpack_require__.r(__webpack_exports__);

// CONCATENATED MODULE: ./src/polyfills.js
// Because Internet Explorer.. All credit due to Mathias Bynens <https://mathiasbynens.be/>
if (!String.prototype.startsWith) {
  (function () {
    'use strict'; // needed to support `apply`/`call` with `undefined`/`null`

    var defineProperty = function () {
      // IE 8 only supports `Object.defineProperty` on DOM elements
      try {
        var object = {};
        var $defineProperty = Object.defineProperty;
        var result = $defineProperty(object, object, object) && $defineProperty;
      } catch (error) {}

      return result;
    }();

    var toString = {}.toString;

    var startsWith = function startsWith(search) {
      if (this == null) {
        throw TypeError();
      }

      var string = String(this);

      if (search && toString.call(search) == '[object RegExp]') {
        throw TypeError();
      }

      var stringLength = string.length;
      var searchString = String(search);
      var searchLength = searchString.length;
      var position = arguments.length > 1 ? arguments[1] : undefined; // `ToInteger`

      var pos = position ? Number(position) : 0;

      if (pos != pos) {
        // better `isNaN`
        pos = 0;
      }

      var start = Math.min(Math.max(pos, 0), stringLength); // Avoid the `indexOf` call if no match is possible

      if (searchLength + start > stringLength) {
        return false;
      }

      var index = -1;

      while (++index < searchLength) {
        if (string.charCodeAt(start + index) != searchString.charCodeAt(index)) {
          return false;
        }
      }

      return true;
    };

    if (defineProperty) {
      defineProperty(String.prototype, 'startsWith', {
        'value': startsWith,
        'configurable': true,
        'writable': true
      });
    } else {
      String.prototype.startsWith = startsWith;
    }
  })();
}

if (!String.prototype.endsWith) {
  (function () {
    'use strict'; // needed to support `apply`/`call` with `undefined`/`null`

    var defineProperty = function () {
      // IE 8 only supports `Object.defineProperty` on DOM elements
      try {
        var object = {};
        var $defineProperty = Object.defineProperty;
        var result = $defineProperty(object, object, object) && $defineProperty;
      } catch (error) {}

      return result;
    }();

    var toString = {}.toString;

    var endsWith = function endsWith(search) {
      if (this == null) {
        throw TypeError();
      }

      var string = String(this);

      if (search && toString.call(search) == '[object RegExp]') {
        throw TypeError();
      }

      var stringLength = string.length;
      var searchString = String(search);
      var searchLength = searchString.length;
      var pos = stringLength;

      if (arguments.length > 1) {
        var position = arguments[1];

        if (position !== undefined) {
          // `ToInteger`
          pos = position ? Number(position) : 0;

          if (pos != pos) {
            // better `isNaN`
            pos = 0;
          }
        }
      }

      var end = Math.min(Math.max(pos, 0), stringLength);
      var start = end - searchLength;

      if (start < 0) {
        return false;
      }

      var index = -1;

      while (++index < searchLength) {
        if (string.charCodeAt(start + index) != searchString.charCodeAt(index)) {
          return false;
        }
      }

      return true;
    };

    if (defineProperty) {
      defineProperty(String.prototype, 'endsWith', {
        'value': endsWith,
        'configurable': true,
        'writable': true
      });
    } else {
      String.prototype.endsWith = endsWith;
    }
  })();
}

/* harmony default export */ var polyfills = (true);
// EXTERNAL MODULE: external {"amd":"d3","root":"d3","commonjs":"d3","commonjs2":"d3"}
var external_amd_d3_root_d3_commonjs_d3_commonjs2_d3_ = __webpack_require__(0);

// CONCATENATED MODULE: ./src/sg.axis.js
/* harmony default export */ var sg_axis = (function (SimpleGraph) {
  SimpleGraph.prototype.resetAxisOptions = function (axisOptions) {
    if (!axisOptions) {
      axisOptions = {};
    }

    if (!axisOptions.x) {
      axisOptions.x = {};
    }

    if (!axisOptions.y) {
      axisOptions.y = {};
    }

    if (!axisOptions.styles) {
      axisOptions.styles = {};
    } // default axis styles


    this.axisStyles = axisOptions.style;
    this.axisStyles = this.axisStyles || {};
    this.axisStyles.fill = this.axisStyles.fill || "none";
    this.axisStyles["stroke-width"] = this.axisStyles["stroke-width"] || 0.5;
    this.axisStyles.stroke = this.axisStyles.stroke || "black"; // loop per axis to remove redundancies

    var axes = ["x", "y", "y2"];

    for (var i = 0; i < axes.length; i++) {
      // specific axis options
      var a = axes[i];

      if (!axisOptions[a]) {
        // if no second y-axis, just skip
        if (a === "y2") continue;
        axisOptions[a] = {};
      }

      if (!axisOptions[a].scale) {
        axisOptions[a].scale = d3.scaleLinear;
      }

      var scaleIsTime = axisOptions[a].scale === d3.scaleTime || axisOptions[a].scale === d3.scaleUtc;
      var scaleIsLog = !scaleIsTime && axisOptions[a].scale === d3.scaleLog;

      if (!axisOptions[a].format) {
        if (scaleIsTime) {
          axisOptions[a].format = "%Y-%m-%d";
        } else {
          axisOptions[a].format = ".0f";
        }
      }

      if (!axisOptions[a].grid) {
        axisOptions[a].grid = {};
      }

      if (scaleIsLog && !axisOptions[a].logBase) {
        axisOptions[a].logBase = 10;
      }

      this[a] = {
        label: axisOptions[a].label === null ? a === "x" ? "x-value" : "y-value" : axisOptions[a].label,
        isDate: scaleIsTime,
        isLog: scaleIsLog
      };

      if (scaleIsTime) {
        if (axisOptions[a].scale === d3.scaleUtc) {
          this[a].format = d3.utcFormat(axisOptions[a].format);
        } else {
          this[a].format = d3.timeFormat(axisOptions[a].format);
        }
      } else {
        this[a].format = d3.format(axisOptions[a].format);
      }

      this[a].min = axisOptions[a].min ? axisOptions[a].min : 0;
      this[a].max = axisOptions[a].max ? axisOptions[a].max : 100; // create scale

      this[a].scale = axisOptions[a].scale();

      if (scaleIsLog) {
        this[a].scale.base(axisOptions[a].logBase);
      }

      var domain, range;

      if (axisOptions[a]["break"]) {
        this[a]["break"] = axisOptions[a]["break"];
        domain = [this[a].min, this[a]["break"].domain[0], this[a]["break"].domain[1], this[a].max];
        var domain2 = !scaleIsTime ? domain : domain.map(function (x) {
          return x.getTime();
        });
        var span = a === "x" ? this.width : this.height;
        range = a === "x" ? [0, 0, 0, span] : [span, 0, 0, 0];
        var validspan = span - this[a]["break"].rangegap;
        var rangePerDomain = validspan / (domain2[1] - domain2[0] + domain2[3] - domain2[2]);
        range[1] = rangePerDomain * (domain2[1] - domain2[0]);
        range[2] = range[1] + this[a]["break"].rangegap;
      } else {
        domain = [this[a].min, this[a].max];
        range = a === "x" ? [0, this.width] : [this.height, 0];
      }

      this[a].scale.domain(domain).range(range); // create axes

      var applySecondAxes = false;

      if (a === "x") {
        // create both versions of the axes as we need to apply tick formatting to both here
        applySecondAxes = true;
        this[a].axis = d3.axisBottom(this[a].scale);
        this[a].axisTwo = d3.axisTop(this[a].scale);
        this[a].gridAxis = d3.axisBottom(this[a].scale);
      } else {
        if (a === "y2") {
          this[a].axis = d3.axisRight(this[a].scale);
          this[a].gridAxis = d3.axisRight(this[a].scale);
        } else {
          this[a].axis = d3.axisLeft(this[a].scale);
          this[a].gridAxis = d3.axisLeft(this[a].scale);
        }
      } // log scale handles ticks differently


      if (scaleIsLog) {
        this[a].axis.tickFormat(this[a].format);

        if (axisOptions[a].ticks) {
          this[a].axis.ticks(axisOptions[a].ticks, this[a].format);
        } else {
          this[a].axis.ticks(this[a].format);

          if (axisOptions[a].tickValues) {
            this[a].axis.tickValues(axisOptions[a].tickValues);
          }
        } // repeat on second axis if needed


        if (applySecondAxes) {
          this[a].axisTwo.tickFormat(this[a].format);

          if (axisOptions[a].ticks) {
            this[a].axisTwo.ticks(axisOptions[a].ticks, this[a].format);
          } else {
            this[a].axisTwo.ticks(this[a].format);

            if (axisOptions[a].tickValues) {
              this[a].axisTwo.tickValues(axisOptions[a].tickValues);
            }
          }
        }
      } else {
        // add ticks
        this[a].axis.tickFormat(this[a].format);

        if (axisOptions[a].tickValues) {
          this[a].axis.tickValues(axisOptions[a].tickValues);
          this[a].gridAxis.tickValues(axisOptions[a].tickValues);
        } else if (axisOptions[a].ticks || axisOptions[a].ticks === 0) {
          if (Array.isArray(axisOptions[a].ticks)) {
            this[a].axis.ticks(axisOptions[a].ticks[0], axisOptions[a].ticks[1]);
            this[a].gridAxis.ticks(axisOptions[a].ticks[0], axisOptions[a].ticks[1]);
          } else {
            this[a].axis.ticks(axisOptions[a].ticks);
            this[a].gridAxis.ticks(axisOptions[a].ticks);
          }
        } // add sub-grid-ticks


        this[a].gridAxis.tickFormat(this[a].format);

        if (axisOptions[a].grid.tickValues) {
          this[a].gridAxis.tickValues(axisOptions[a].grid.tickValues);
        } else if (axisOptions[a].grid.ticks || axisOptions[a].grid.ticks === 0) {
          if (Array.isArray(axisOptions[a].grid.ticks)) {
            this[a].gridAxis.ticks(axisOptions[a].grid.ticks[0], axisOptions[a].grid.ticks[1]);
          } else {
            this[a].gridAxis.ticks(axisOptions[a].grid.ticks);
          }
        } // repeat on second axis if needed


        if (applySecondAxes) {
          this[a].axisTwo.tickFormat(this[a].format);

          if (axisOptions[a].tickValues) {
            this[a].axisTwo.tickValues(axisOptions[a].tickValues);
          } else if (axisOptions[a].ticks || axisOptions[a].ticks === 0) {
            if (Array.isArray(axisOptions[a].ticks)) {
              this[a].axisTwo.ticks(axisOptions[a].ticks[0], axisOptions[a].ticks[1]);
            } else {
              this[a].axisTwo.ticks(axisOptions[a].ticks);
            }
          }
        }
      }
    } // for backwards compatibility


    this.minMax = {
      x: [this.x.min, this.x.max],
      y: [this.y.min, this.y.max]
    };
    this.xScale = this.x.scale;
    this.xAxis = this.x.axis;
    this.xGridAxis = this.x.gridAxes;
    this.yScale = this.y.scale;
    this.yAxis = this.y.axis;
    this.yGridAxis = this.y.gridAxes; // draw axes but also clear any drawn lines/points/areas as they'd now be off

    this.removeAll();
    this.drawAxes();
    return this;
  };

  SimpleGraph.prototype.drawAxes = function (labelPosition, xAxisPosition, axisLabelMargin) {
    var _this = this;

    if (!xAxisPosition) {
      xAxisPosition = "bottom";
    } else {
      xAxisPosition = xAxisPosition.toLowerCase().trim();

      if (xAxisPosition !== "top") {
        xAxisPosition = "bottom";
      }
    }

    var xAxis;
    var xAxisPosY = 0;

    if (xAxisPosition !== "top") {
      xAxis = this.x.axis;
      xAxisPosY = this.height;
    } else {
      xAxis = this.x.axisTwo;
    }

    if (!axisLabelMargin) {
      axisLabelMargin = 0;
    } // draw axes first without labels


    this.svg.selectAll(".sg-xaxis, .sg-yaxis, .sg-y2axis, .sg-axis-label").remove();
    var xAxisG = this.svgGraph.append("g").attr("class", "sg-xaxis").attr("transform", "translate(0," + xAxisPosY + ")").call(xAxis) // annoyingly d3 adds these after axis call so remove so they don't override svg style
    .attr("font-size", null).attr("font-family", null);
    var yAxisG = this.svgGraph.append("g").attr("class", "sg-yaxis").call(this.y.axis).attr("font-size", null).attr("font-family", null);
    var y2AxisG = !this.y2 ? null : this.svgGraph.append("g").attr("class", "sg-y2axis").attr("transform", "translate(" + this.width + ",0)").call(this.y2.axis).attr("font-size", null).attr("font-family", null); // for some reason ticks are by default invisible

    this.svgGraph.selectAll(".tick line").style("stroke", "#000"); // add styles

    var axes = this.svgGraph.selectAll(".sg-xaxis .domain, .sg-yaxis .domain, .sg-y2axis .domain");

    for (var style in this.axisStyles) {
      axes.style(style, this.axisStyles[style]);
    } // get size of ticks to know margin to place labels away if outside


    var tickMargin = {
      x: 0,
      y: 0,
      y2: 0
    };
    this.svgGraph.selectAll(".sg-xaxis .tick").each(function () {
      if (this.getBBox().height > tickMargin.x) {
        tickMargin.x = this.getBBox().height;
      }
    });
    this.svgGraph.selectAll(".sg-yaxis .tick").each(function () {
      if (this.getBBox().width > tickMargin.y) {
        tickMargin.y = this.getBBox().width;
      }
    });
    this.svgGraph.selectAll(".sg-y2axis .tick").each(function () {
      if (this.getBBox().width > tickMargin.y2) {
        tickMargin.y2 = this.getBBox().width;
      }
    }); // default position on center-outside

    var xLabelPos = {
      a: 'middle',
      x: 0.5 * this.width,
      y: xAxisPosition === "top" ? -(tickMargin.x + axisLabelMargin) : tickMargin.x + 10 + axisLabelMargin
    };
    var yLabelPos = {
      a: 'middle',
      x: -0.5 * this.height,
      y: -(tickMargin.y + 10 + axisLabelMargin)
    };
    var y2LabelPos = {
      a: 'middle',
      x: 0.5 * this.height,
      y: -(tickMargin.y2 + 10 + axisLabelMargin)
    }; // determine label position

    if (labelPosition) {
      // split by keys
      var lpKeys = labelPosition.toLowerCase().split(/[ ,]+/),
          xparallel = "center",
          yparallel = "center",
          y2parallel = "center",
          xperpendicular = "outside",
          yperpendicular = "outside",
          y2perpendicular = "outside";
      lpKeys.forEach(function (directive) {
        var parts = directive.trim().split("-"),
            axis = parts.length > 1 ? parts[0] : false;
        directive = parts.length > 1 ? parts[parts.length - 1] : parts[0];

        switch (directive) {
          case "outside":
            if (!axis || axis === "x") {
              xLabelPos.y = xAxisPosition === "top" ? -(tickMargin.x + axisLabelMargin) : tickMargin.x + 10 + axisLabelMargin;
              xperpendicular = "outside";
            }

            if (!axis || axis === "y") {
              yLabelPos.y = -(tickMargin.y + 10 + axisLabelMargin);
              yperpendicular = "outside";
            }

            if (!axis || axis === "y2") {
              y2LabelPos.y = -(tickMargin.y2 + 10 + axisLabelMargin);
              y2perpendicular = "outside";
            }

            break;

          case "inside":
            if (!axis || axis === "x") {
              xLabelPos.y = xAxisPosition === "top" ? 14 + axisLabelMargin : -(6 + axisLabelMargin);
              xperpendicular = "inside";
            }

            if (!axis || axis === "y") {
              yLabelPos.y = 5;
              yperpendicular = "inside";
            }

            if (!axis || axis === "y2") {
              y2LabelPos.y = 5;
              y2perpendicular = "inside";
            }

          case "center":
            if (!axis || axis === "x") {
              xLabelPos.a = 'middle';
              xLabelPos.x = 0.5 * _this.width;
              xparallel = "center";
            }

            if (!axis || axis === "y") {
              yLabelPos.a = 'middle';
              yLabelPos.x = -0.5 * _this.height;
              yparallel = "center";
            }

            if (!axis || axis === "y2") {
              y2LabelPos.a = 'middle';
              y2LabelPos.x = 0.5 * _this.height;
              y2parallel = "center";
            }

            break;

          case "left":
            xLabelPos.a = 'start';
            xLabelPos.x = 0;
            xparallel = "left";
            break;

          case "right":
            xLabelPos.a = 'end';
            xLabelPos.x = _this.width;
            xparallel = "right";
            break;

          case "top":
            if (!axis || axis === "y") {
              yLabelPos.a = 'end';
              yLabelPos.x = 0;
              yparallel = "top";
            }

            if (!axis || axis === "y2") {
              y2LabelPos.a = 'start';
              y2LabelPos.x = 0;
              y2parallel = "top";
            }

            break;

          case "bottom":
            if (!axis || axis === "y") {
              yLabelPos.a = 'start';
              yLabelPos.x = -_this.height;
              yparallel = "bottom";
            }

            if (!axis || axis === "y2") {
              y2LabelPos.a = 'end';
              y2LabelPos.x = _this.height;
              y2parallel = "bottom";
            }

            break;
        }
      }); // if near axis crossing, needs some extra padding

      if (xperpendicular === "inside") {
        if (xparallel === "left") {
          xLabelPos.x += 10;
        } else if (xparallel === "right" && this.y2) {
          xLabelPos.x -= 10;
        }

        if (xAxisPosition === "bottom") {
          if (xparallel === "left" && yperpendicular === "inside" && yparallel === "bottom") {
            xLabelPos.x += 10;
            yLabelPos.x += 10;
          }

          if (xparallel === "right" && this.y2 && y2perpendicular === "inside" && y2parallel === "bottom") {
            xLabelPos.x -= 10;
            y2LabelPos.x -= 10;
          }
        } else {
          if (xparallel === "left" && yperpendicular === "inside" && yparallel === "top") {
            xLabelPos.x += 10;
            yLabelPos.x -= 10;
          }

          if (xparallel === "right" && this.y2 && y2perpendicular === "inside" && y2parallel === "top") {
            xLabelPos.x -= 10;
            y2LabelPos.x += 10;
          }
        }
      }
    }

    if (yperpendicular === "inside") {
      if (yparallel === "top") yLabelPos.x -= 5;
      if (yparallel === "bottom") yLabelPos.x += 5;
    }

    if (y2perpendicular === "inside") {
      if (y2parallel === "top") y2LabelPos.x += 5;
      if (y2parallel === "bottom") y2LLabelPos.x -= 5;
    } // add labels


    xAxisG.append("text").attr("class", "sg-axis-label sg-xaxis").attr("x", xLabelPos.x).attr("y", xLabelPos.y).attr("fill", "#000").style("text-anchor", xLabelPos.a).style("font-weight", "bolder").text(this.x.label);
    yAxisG.append("text").attr("class", "sg-axis-label sg-yaxis").attr("transform", "rotate(-90)").attr("x", yLabelPos.x).attr("y", yLabelPos.y).attr("dy", ".71em").attr("fill", "#000").style("text-anchor", yLabelPos.a).style("font-weight", "bolder").text(this.y.label);

    if (y2AxisG) {
      y2AxisG.append("text").attr("class", "sg-axis-label sg-y2axis").attr("transform", "rotate(90)").attr("x", y2LabelPos.x).attr("y", y2LabelPos.y).attr("dy", ".71em").attr("fill", "#000").style("text-anchor", y2LabelPos.a).style("font-weight", "bolder").text(this.y2.label);
    }

    return this;
  };
});
// CONCATENATED MODULE: ./src/sg.color.js
/* harmony default export */ var sg_color = (function (SimpleGraph) {
  SimpleGraph.prototype.getColorBySeriesName = function (name, create) {
    if (!name) {
      return null;
    }

    if (name in this.customColors) {
      return this.customColors[name];
    }

    if (this.points) {
      for (var p in this.points) {
        var point = this.points[p];

        if (name === point.series) {
          // TODO, no style options yet available for points data
          if (point.style && point.style.fill) {
            return point.style.fill;
          } else {
            if (create) {
              return this.color(name);
            }

            return this.color.domain().indexOf(name) >= 0 ? this.color(name) : null;
          }
        }
      }
    }

    if (this.lines) {
      for (var l in this.lines) {
        var line = this.lines[l];

        if (name === line.series) {
          if (line.style && line.style.stroke) {
            return line.style.stroke;
          } else {
            if (create) {
              return this.color(name);
            }

            return this.color.domain().indexOf(name) >= 0 ? this.color(name) : null;
          }
        }
      }
    }

    if (this.areas) {
      for (var a in this.areas) {
        var area = this.areas[a];

        if (name === area.series) {
          if (area.style && area.style.fill) {
            return area.style.fill;
          } else {
            if (create) {
              return this.color(name);
            }

            return this.color.domain().indexOf(name) >= 0 ? this.color(name) : null;
          }
        }
      }
    }

    if (create) {
      return this.color(name);
    }
  };

  SimpleGraph.prototype.resetColorScale = function (colorScale) {
    if (colorScale) {
      this.color = colorScale;
    } else {
      this.color.domain([]);
    }

    return this;
  };

  SimpleGraph.prototype.setSeriesColor = function (series, color) {
    this.customColors[series] = color;
  };

  SimpleGraph.prototype.removeSeriesColor = function (series) {
    if (this.customColors[series]) {
      delete this.customColors[series];
    }

    ;
    return this;
  };
});
// CONCATENATED MODULE: ./src/sg.point.shapes.js
/* harmony default export */ var sg_point_shapes = (["diamond", "circle", "square", "triangle", "triangle-up", "triangle-down"]);
// CONCATENATED MODULE: ./src/sg.grid.legend.js

/* harmony default export */ var sg_grid_legend = (function (SimpleGraph) {
  SimpleGraph.prototype.drawGrid = function (style) {
    this.svgGraph.selectAll(".sg-grid").remove(); // default styles

    var opacity = style && style.opacity ? parseFloat(style.opacity) : 0.4;
    var stroke = style && style.stroke ? style.stroke : "#555";
    var strokeWidth = style && style['stroke-width'] ? parseFloat(style['stroke-width']) : 0.3;
    this.svgGraph.append("g").attr("class", "sg-grid").attr("transform", "translate(0," + this.height + ")").style("opacity", opacity).style("stroke", stroke).style("stroke-width", strokeWidth).call(this.x.gridAxis.tickSize(-this.height).tickFormat(""));
    this.svgGraph.append("g").attr("class", "sg-grid").attr("opacity", opacity).style("stroke", stroke).style("stroke-width", strokeWidth).call(this.y.gridAxis.tickSize(-this.width).tickFormat(""));
    return this;
  };

  SimpleGraph.prototype.removeGrid = function () {
    this.svgGraph.selectAll(".sg-grid").remove();
    return this;
  };

  SimpleGraph.prototype.drawLegend = function (position, options) {
    this.svg.selectAll(".sg-legend").remove();

    if (!position) {
      position = {
        x: 0,
        y: 0
      };
    } else if (!position.x || !position.y) {
      if (!position.x && position.x !== 0) {
        position.x = position[0] !== undefined && typeof position[0] === "number" ? position[0] : this.width + 5;
      }

      if (!position.y && position.y !== 0) {
        position.y = position[1] !== undefined && typeof position[1] === "number" ? position[1] : 0;
      }
    }

    options = options || {};
    var anchor = options.anchor || "left",
        bgstyle = options.bgstyle || {},
        exclude = options.exclude || [];

    if (!exclude) {
      exclude = [];
    }

    if (typeof exclude === "string") {
      exclude = exclude.trim().split(/\s+/);
    }

    for (var i = 0; i < exclude.length; i++) {
      exclude[i] = exclude[i].toLowerCase();
    } // default styles for legend container (padding is set via explicit sides)


    if (bgstyle.padding) {
      var pads = typeof bgstyle.padding === "string" ? bgstyle.padding.split(" ") : [bgstyle.padding];

      if (pads.length === 1) {
        bgstyle['padding-left'] = pads[0];
        bgstyle['padding-right'] = pads[0];
        bgstyle['padding-top'] = pads[0];
        bgstyle['padding-bottom'] = pads[0];
      } else if (pads.length === 2) {
        bgstyle['padding-left'] = pads[1];
        bgstyle['padding-right'] = pads[1];
        bgstyle['padding-top'] = pads[0];
        bgstyle['padding-bottom'] = pads[0];
      } else {
        if (pads.length > 3) {
          bgstyle['padding-left'] = pads[3];
        }

        bgstyle['padding-right'] = pads[1];
        bgstyle['padding-top'] = pads[0];
        bgstyle['padding-bottom'] = pads[2];
      }

      delete bgstyle.padding;
    } else {
      if (!bgstyle['padding-left']) {
        bgstyle['padding-left'] = 0;
      }

      if (!bgstyle['padding-right']) {
        bgstyle['padding-right'] = 0;
      }

      if (!bgstyle['padding-top']) {
        bgstyle['padding-top'] = 0;
      }

      if (!bgstyle['padding-bottom']) {
        bgstyle['padding-bottom'] = 0;
      }
    }

    if (!bgstyle.fill) {
      bgstyle.fill = "#fff";
      bgstyle.opacity = 0;
    } // ensure int type


    bgstyle['padding-left'] = parseInt(bgstyle['padding-left']);
    bgstyle['padding-right'] = parseInt(bgstyle['padding-right']);
    bgstyle['padding-top'] = parseInt(bgstyle['padding-top']);
    bgstyle['padding-bottom'] = parseInt(bgstyle['padding-bottom']); // create legend graphic and background (note, added to top SVG not svgGraph)

    var legend = this.svg.append("g").attr("class", "sg-legend").attr("transform", "translate(" + position.x + "," + position.y + ")"),
        legendBg = legend.append("rect").attr("class", "sg-legend-bg").attr("x", 0).attr("y", 0);

    for (var skey in bgstyle) {
      if (!skey.startsWith('padding')) {
        legendBg.style(skey, bgstyle[skey]);
      }
    } // column parameters


    var itemsPerColumn = options.itemsPerColumn || 0,
        rowHeight = options.rowHeight || 24,
        columnNumber = 0,
        columnItemCount = 0,
        // running position for next item
    yOffset = bgstyle['padding-top'],
        xOffset = bgstyle['padding-left']; // local function checks for new column and adjusts position if so

    function addAndCheckColumn() {
      columnItemCount++;

      if (itemsPerColumn > 0 && columnItemCount >= itemsPerColumn) {
        columnNumber++;
        columnItemCount = 0;
        yOffset = bgstyle['padding-top'];
        xOffset = legend.node().getBBox().width + 12;
      } else {
        yOffset += rowHeight;
      }
    } // local functions for adding items to legend by data type (not needed yet but will make custom item order
    // easier for future)


    var self = this;

    function addPointItem(data, shape, drawPointLine) {
      if (drawPointLine) {
        var lineOffset = yOffset + 10,
            path = legend.append("path").attr("x", xOffset).attr("y", yOffset).attr("d", "M" + xOffset + " " + lineOffset + " " + "L" + (18 + xOffset) + " " + lineOffset); // remember styles are only stored in first since they're shared

        for (var style in self.pointLines[0].style) {
          path.style(style, self.pointLines[0].style[style]);
        }

        path.style("stroke", self.getColorBySeriesName(data.series));
      }

      var size = typeof data.size === "function" ? data.size() : data.size;

      if (size > 14) {
        size = 14;
      }

      var ioffx = xOffset + 2,
          ioffy = yOffset + 3;

      if (shape && shape.startsWith("triangle")) {
        var length = size * 1.519676,
            // side length of equilateral trangle of same area of square
        hl = length / 2.0,
            hlDiff = 7 - hl,
            height = length * 0.86602,
            // ratio of equilateral triangle
        hh = height * 0.5,
            hhDiff = 7 - hh;
        ioffx += hlDiff;
        ioffy += hhDiff;

        switch (shape) {
          case "triangle-down":
            legend.append("polygon").attr("points", "".concat(ioffx, ",").concat(ioffy + height, " ") + "".concat(ioffx + hl, ",").concat(ioffy, " ") + "".concat(ioffx + length, ",").concat(ioffy + height)).style("fill", self.getColorBySeriesName(data.series));
            break;

          case "triangle":
          case "triangle-up":
            legend.append("polygon").attr("points", "".concat(ioffx, ",").concat(ioffy, " ") + "".concat(ioffx + hl, ",").concat(ioffy + height, " ") + "".concat(ioffx + length, ",").concat(ioffy)).style("fill", self.getColorBySeriesName(data.series));
            break;
        }
      } else {
        var hs = size / 2.0,
            hsDiff = 7 - hs;
        ioffx += hsDiff;
        ioffy += hsDiff;

        switch (shape) {
          case "circle":
            legend.append("circle").attr("cx", ioffx + hs).attr("cy", ioffy + hs).attr("r", hs).style("fill", self.getColorBySeriesName(data.series));
            break;

          case "square":
          case "diamond":
          default:
            legend.append("rect").attr("x", ioffx).attr("y", ioffy).attr("width", size).attr("height", size).attr("transform", shape == "square" ? "" : "rotate(45,".concat(ioffx + hs, ",").concat(ioffy + hs, ")")).style("fill", self.getColorBySeriesName(data.series));
            break;
        }
      }

      legend.append("text").attr("x", xOffset + 23).attr("y", yOffset + 9).attr("dy", ".35em").style("text-anchor", "start").text(data.series);
      addAndCheckColumn();
    }

    function addLineItem(data) {
      var lineOffset = yOffset + 10;
      var path = legend.append("path").attr("x", xOffset).attr("y", yOffset).attr("d", "M" + xOffset + " " + lineOffset + " " + "L" + (18 + xOffset) + " " + lineOffset);

      for (var style in data.style) {
        path.style(style, data.style[style]);
      }

      if (!("stroke" in data.style)) {
        path.style("stroke", self.getColorBySeriesName(data.series));
      }

      legend.append("text").attr("x", xOffset + 23).attr("y", yOffset + 9).attr("dy", ".35em").style("text-anchor", "start").text(data.series);
      addAndCheckColumn();
    }

    function addAreaItem(data) {
      var symbol = legend.append("rect").attr("x", xOffset).attr("y", yOffset).attr("width", 18).attr("height", 18);

      for (var style in data.style) {
        symbol.style(style, data.style[style]);
      }

      if (!("fill" in data.style)) {
        symbol.style("fill", self.getColorBySeriesName(data.series));
      }

      legend.append("text").attr("x", xOffset + 23).attr("y", yOffset + 9).attr("dy", ".35em").style("text-anchor", "start").text(data.series);
      addAndCheckColumn();
    } // start with areas data


    if (this.areas && !~exclude.indexOf("areas")) {
      var areaSeries = [];

      for (var _i = 0; _i < this.areas.length; _i++) {
        var name = this.areas[_i].series;

        if (!~areaSeries.indexOf(name)) {
          areaSeries.push(name);
          addAreaItem(this.areas[_i]);
        }
      }
    } // then lines


    if (this.lines && !~exclude.indexOf("lines")) {
      var lineSeries = [];

      for (var _i2 = 0; _i2 < this.lines.length; _i2++) {
        var _name = this.lines[_i2].series;

        if (!~lineSeries.indexOf(_name)) {
          lineSeries.push(_name);
          addLineItem(this.lines[_i2]);
        }
      }
    } // finally points


    if (this.points && !~exclude.indexOf("points")) {
      var pointSeries = [];

      for (var _i3 = 0; _i3 < this.points.length; _i3++) {
        var _name2 = this.points[_i3].series;

        if (!~pointSeries.indexOf(_name2)) {
          pointSeries.push(_name2); // find connected point line series, if it exists

          var drawPointLine = false;

          if (this.pointLines) {
            var j = this.pointLines.length;

            while (j--) {
              if (this.pointLines[j].series === _name2) {
                drawPointLine = true;
                break;
              }
            }
          }

          addPointItem(this.points[_i3], this.getPointSeriesShape(_name2), drawPointLine);
        }
      }
    } // finish up legend bg after completing elements inside


    var legendBox = legend.node().getBBox();
    legendBg.attr("width", legendBox.width + bgstyle['padding-left'] + bgstyle['padding-right']).attr("height", legendBox.height + bgstyle['padding-top'] + bgstyle['padding-bottom']); // adjust legend position if necessary

    anchor = anchor.trim().toLowerCase();

    if (anchor === "middle") {
      position.x -= 0.5 * legendBox.width;
    } else if (anchor === "right") {
      position.x -= legendBox.width;
    }

    legend.attr("transform", "translate(" + position.x + "," + position.y + ")");
    return this;
  };
});
// CONCATENATED MODULE: ./src/sg.data.point.js

/* harmony default export */ var sg_data_point = (function (SimpleGraph) {
  SimpleGraph.prototype.addPointData = function (series, xValue, yValue, options) {
    this.points = this.points || [];
    this.ptSeriesShapes = this.ptSeriesShapes || {};
    options = options || {};
    options.size = !options.size || typeof options.size !== "function" && options.size <= 0 ? options.size = 10 : options.size;
    options.y2Axis = !!options.y2Axis;
    options.showNulls = !!options.showNulls;
    if (options.shape) this.setPointSeriesShape(series, options.shape);
    var p = {
      series: series,
      x: parseFloat(xValue),
      y: parseFloat(yValue),
      y2: options.y2Axis,
      size: options.size,
      _bind: null,
      _keys: null
    };

    if (isNaN(p.y) || !p.y && p.y !== 0) {
      if (showNulls) {
        p.y = 0;
        p.wasNull = true;
      } else {
        return this;
      }
    }

    this.points.push(p);
    return this;
  };

  SimpleGraph.prototype.addPointsData = function (data, seriesName, xValueName, yValueName, options) {
    var _this = this;

    if (!data || data.length === 0) return this;
    this.points = this.points || [];
    this.ptSeriesShapes = this.ptSeriesShapes || {};
    options = options || {};
    options.size = !options.size || typeof options.size !== "function" && options.size <= 0 ? options.size = 10 : options.size;
    options.y2Axis = !!options.y2Axis;
    options.showNulls = !!options.showNulls;
    options.additionalDataKeys = options.additionalDataKeys || null; // first we gotta comb through the data and organize it nicely

    var self = this;
    data.forEach(function (datum, i) {
      // get data series name, if it exists, otherwise assume seriesName is series name
      var series = !seriesName ? i : datum[seriesName] ? datum[seriesName] : seriesName,
          xValue = datum[xValueName],
          yValue = datum[yValueName]; // add shape if provided as constant string

      if (options.shape) self.ptSeriesShapes[series] = options.shape; // nicely organize data

      var point = {
        series: series,
        x: xValue,
        y: parseFloat(yValue),
        y2: options.y2Axis,
        size: options.size,
        _bind: datum,
        _keys: {
          x: xValueName,
          y: yValueName,
          additional: null
        }
      }; // check for nulls

      if (isNaN(point.y) || !point.y && point.y !== 0) {
        if (!showNulls) return;
        point.y = 0;
        point.wasNull = true;
      } // additonal keys


      if (options.additionalDataKeys && Array.isArray(options.additionalDataKeys)) {
        var addKeys = [];
        options.additionalDataKeys.forEach(function (key) {
          var name = key,
              t = 1; // if key exists (name, x, y are reserved), adjust key name

          while (name in point) {
            name = key + String(++t);
          }

          addKeys.push({
            key: key,
            name: name
          });
          point[name] = datum[key];
        });
        point._keys.additional = addKeys;
      }

      _this.points.push(point);
    });
    return this;
  };

  SimpleGraph.prototype.addPointsDataAsArray = function (series, data, options) {
    if (!data || data.length === 0) return this;
    this.points = this.points || [];
    this.ptSeriesShapes = this.ptSeriesShapes || {};
    options = options || {};
    options.size = !options.size || typeof options.size !== "function" && options.size <= 0 ? options.size = 10 : options.size;
    options.y2Axis = !!options.y2Axis;
    options.showNulls = !!options.showNulls;
    if (options.shape) this.setPointSeriesShape(series, options.shape);
    var self = this;
    data.forEach(function (datum) {
      var p = {
        series: series,
        x: parseFloat(datum[0]),
        y: parseFloat(datum[1]),
        y2: options.y2Axis,
        size: options.size,
        _bind: datum,
        _keys: {
          x: 0,
          y: 1,
          additional: null
        }
      };

      if (isNaN(p.y) || !p.y && p.y !== 0) {
        if (!showNulls) return;
        p.y = 0;
        p.wasNull = true;
      }

      self.points.push(p);
    });
    return this;
  };

  SimpleGraph.prototype.clearPointsData = function (series) {
    if (!series) {
      this.points = null;
    } else {
      this.points = this.points.filter(function (d) {
        return d.series !== series;
      });
    }

    return this;
  };

  SimpleGraph.prototype.getPointsDataBySeries = function (series) {
    if (!this.points) return [];
    return this.points.filter(function (c) {
      return c.series === series;
    }).map(function (d) {
      return {
        x: d.x,
        y: d.y,
        y2: d.y2,
        size: d.size
      };
    });
  };

  SimpleGraph.prototype.getPointCoordinatesBySeries = function (series) {
    if (!this.points) return [];
    return this.points.filter(function (c) {
      return c.series === series;
    }).map(function (c) {
      return [c.x, c.y || c.y === 0 ? c.y : c.y2];
    });
  };

  SimpleGraph.prototype.getPointSeriesShape = function (series) {
    this.ptSeriesShapes = this.ptSeriesShapes || {};
    return this.ptSeriesShapes[series];
  };

  SimpleGraph.prototype.setPointSeriesShape = function (series, shape) {
    this.ptSeriesShapes = this.ptSeriesShapes || {};
    this.ptSeriesShapes[series] = ~sg_point_shapes.indexOf(shape) ? shape : null;
    return this;
  };

  SimpleGraph.prototype.updatePointsData = function () {
    if (!this.points) return this;
    this.points.forEach(function (d) {
      if (!d._bind || d._keys) return;
      d.x = parseFloat(d._bind[d._keys.x]);
      d.y = parseFloat(d._bind[d._keys.y]);
      if (!d._keys.a) return;

      d._keys.additional.forEach(function (a) {
        return d[a.name] = d._bind[a.key];
      });
    });
    if (!this.pointLines) return this; // first organize points by data series

    var pointsBySeries = {};

    for (var i = 0; i < this.points.length; i++) {
      var series = this.points[i].series;

      if (series in pointsBySeries) {
        pointsBySeries[series].push(this.points[i]);
      } else {
        pointsBySeries[series] = [this.points[i]];
      }
    } // update existing point-line data


    var self = this;
    this.pointLines = this.pointLines.filter(function (d) {
      if (!(d.series in pointsBySeries)) return false;
      d.coords = self._getPointLine(pointsBySeries[d.series]);
      return true;
    });
    return this;
  };
});
// CONCATENATED MODULE: ./src/sg.data.area.js
function _toConsumableArray(arr) { return _arrayWithoutHoles(arr) || _iterableToArray(arr) || _unsupportedIterableToArray(arr) || _nonIterableSpread(); }

function _nonIterableSpread() { throw new TypeError("Invalid attempt to spread non-iterable instance.\nIn order to be iterable, non-array objects must have a [Symbol.iterator]() method."); }

function _unsupportedIterableToArray(o, minLen) { if (!o) return; if (typeof o === "string") return _arrayLikeToArray(o, minLen); var n = Object.prototype.toString.call(o).slice(8, -1); if (n === "Object" && o.constructor) n = o.constructor.name; if (n === "Map" || n === "Set") return Array.from(o); if (n === "Arguments" || /^(?:Ui|I)nt(?:8|16|32)(?:Clamped)?Array$/.test(n)) return _arrayLikeToArray(o, minLen); }

function _iterableToArray(iter) { if (typeof Symbol !== "undefined" && Symbol.iterator in Object(iter)) return Array.from(iter); }

function _arrayWithoutHoles(arr) { if (Array.isArray(arr)) return _arrayLikeToArray(arr); }

function _arrayLikeToArray(arr, len) { if (len == null || len > arr.length) len = arr.length; for (var i = 0, arr2 = new Array(len); i < len; i++) { arr2[i] = arr[i]; } return arr2; }

/* harmony default export */ var sg_data_area = (function (SimpleGraph, d3) {
  SimpleGraph.prototype.addAreaBetweenTwoLines = function (name, lineFunctionBottom, lineFunctionTop, style, resolution, interpolation, xRange, y2Axis) {
    if (!lineFunctionTop || typeof lineFunctionTop !== "function") {
      return this;
    }

    if (!lineFunctionBottom || typeof lineFunctionBottom !== "function") {
      return this;
    } // default styles


    if (!style) {
      style = {};
    }

    if (!interpolation) {
      interpolation = d3.curveLinear;
    }

    if (!this.areas) {
      this.areas = [];
    }

    this.areas.push({
      series: name,
      areaFunctions: [lineFunctionBottom, lineFunctionTop],
      coords: null,
      resolution: resolution,
      xRange: xRange,
      y2: y2Axis ? true : false,
      style: style,
      interpolate: interpolation
    });
    return this;
  };

  SimpleGraph.prototype.addAreaAsCoordinates = function (name, areaCoordinates, style, interpolation, y2Axis) {
    if (!areaCoordinates || !Array.isArray(areaCoordinates) || areaCoordinates.length < 2) {
      return this;
    } // default styles


    if (!style) {
      style = {};
    }

    if (!interpolation) {
      interpolation = d3.curveLinear;
    }

    if (!this.areas) {
      this.areas = [];
    }

    this.areas.push({
      series: name,
      areaFunctions: null,
      coords: areaCoordinates,
      resolution: null,
      xRange: null,
      y2: y2Axis ? true : false,
      style: style,
      interpolate: interpolation
    });
    return this;
  };

  SimpleGraph.prototype.getAreasDataBySeries = function (series) {
    if (!this.areas) return [];
    return this.areas.filter(function (d) {
      return d.series === series;
    }).map(function (d) {
      return {
        series: d.series,
        areaFunctions: d.areaFunctions,
        coords: d.coords.map(function (c) {
          return _toConsumableArray(c);
        }),
        resolution: d.resolution,
        xRange: _toConsumableArray(d.xRange),
        y2: d.y2,
        style: d.style,
        interpolate: d.interpolation
      };
    });
  };

  SimpleGraph.prototype.clearAreasData = function (series) {
    if (!series) {
      this.areas = null;
    } else {
      this.areas = this.areas.filter(function (d) {
        return d.series !== series;
      });
    }

    return this;
  };
});
// CONCATENATED MODULE: ./src/sg.data.line.js
function sg_data_line_toConsumableArray(arr) { return sg_data_line_arrayWithoutHoles(arr) || sg_data_line_iterableToArray(arr) || sg_data_line_unsupportedIterableToArray(arr) || sg_data_line_nonIterableSpread(); }

function sg_data_line_nonIterableSpread() { throw new TypeError("Invalid attempt to spread non-iterable instance.\nIn order to be iterable, non-array objects must have a [Symbol.iterator]() method."); }

function sg_data_line_unsupportedIterableToArray(o, minLen) { if (!o) return; if (typeof o === "string") return sg_data_line_arrayLikeToArray(o, minLen); var n = Object.prototype.toString.call(o).slice(8, -1); if (n === "Object" && o.constructor) n = o.constructor.name; if (n === "Map" || n === "Set") return Array.from(o); if (n === "Arguments" || /^(?:Ui|I)nt(?:8|16|32)(?:Clamped)?Array$/.test(n)) return sg_data_line_arrayLikeToArray(o, minLen); }

function sg_data_line_iterableToArray(iter) { if (typeof Symbol !== "undefined" && Symbol.iterator in Object(iter)) return Array.from(iter); }

function sg_data_line_arrayWithoutHoles(arr) { if (Array.isArray(arr)) return sg_data_line_arrayLikeToArray(arr); }

function sg_data_line_arrayLikeToArray(arr, len) { if (len == null || len > arr.length) len = arr.length; for (var i = 0, arr2 = new Array(len); i < len; i++) { arr2[i] = arr[i]; } return arr2; }

/* harmony default export */ var sg_data_line = (function (SimpleGraph, d3) {
  SimpleGraph.prototype.addLineDataAsCoordinates = function (name, coords, options) {
    if (!coords || coords.length === 0) {
      return this;
    }

    this.lines = this.lines || []; //coords.sort(function(a, b) { return a[0] - b[0]; });
    // defaults

    options = options || {};
    var style = options.style || {};

    if (!style['stroke-width'] || typeof style['stroke-width'] !== "number") {
      style['stroke-width'] = 1.5;
    }

    this.lines.push({
      series: name,
      lineFunction: null,
      coords: coords.map(function (c) {
        return sg_data_line_toConsumableArray(c);
      }),
      xRange: null,
      y2: !!options.y2Axis,
      style: style,
      interpolate: options.interpolation || d3.curveLinear,
      _bind: {
        coords: coords
      }
    });
    return this;
  };

  SimpleGraph.prototype.addLineDataAsFunction = function (name, lineFunction, xRange, options) {
    if (!lineFunction || typeof lineFunction !== "function" || typeof lineFunction(0) !== "number") {
      return this;
    }

    this.lines = this.lines || []; // defaults

    options = options || {};
    var style = options.style || {};

    if (!style['stroke-width'] || typeof style['stroke-width'] !== "number") {
      style['stroke-width'] = 1.5;
    }

    var interpolation = interpolation || d3.curveLinear;
    this.lines.push({
      series: name,
      lineFunction: lineFunction,
      coords: null,
      xRange: xRange ? sg_data_line_toConsumableArray(xRange) : null,
      y2: !!options.y2Axis,
      style: style,
      interpolate: options.interpolation || d3.curveLinear,
      _bind: {
        xRange: xRange
      }
    });
    return this;
  };

  SimpleGraph.prototype.addLinesDataFromPoints = function (forSeries, options) {
    if (!this.points || this.points.length === 0) return this;
    options = options || {};
    var handleOverlap = !options.handleOverlap ? 'average' : options.handleOverlap.toLowerCase(); // default styles

    var style = options.style || {};

    if (!style['stroke-width'] || typeof style['stroke-width'] !== "number") {
      style['stroke-width'] = 1.5;
    } // can't specify color, will be taken from related point data series


    if (style.stroke) delete style.stroke; // this multiple series of loops isn't pretty but necessary for flexible preprocessing
    // first organize points by data series

    var pointsBySeries = {};

    for (var i = 0; i < this.points.length; i++) {
      var series = this.points[i].series;

      if (series in pointsBySeries) {
        pointsBySeries[series].y2 = this.points[i].y2;
        pointsBySeries[series].points.push(this.points[i]);
      } else {
        pointsBySeries[series] = {
          points: [this.points[i]]
        };
      }
    } // change forSeries to function


    var checkSeries = function checkSeries(s) {
      return true;
    };

    if (forSeries) {
      if (typeof forSeries === "function") {
        checkSeries = forSeries;
      } else if (typeof forSeries === "string") {
        checkSeries = function checkSeries(s) {
          return s === forSeries;
        };
      } else if (Array.isArray(forSeries)) {
        checkSeries = function checkSeries(s) {
          return ~forSeries.indexOf(s);
        };
      }
    } // will be our array of point-connecting-lines


    this.pointLines = [];

    for (var _series in pointsBySeries) {
      if (!checkSeries(_series) || pointsBySeries[_series].points.length < 2) continue;

      var lineCoords = this._getPointLine(pointsBySeries[_series].points, handleOverlap);

      if (lineCoords.length >= 2) {
        this.pointLines.push({
          series: _series,
          coords: lineCoords,
          y2: pointsBySeries[_series].y2,
          style: style,
          interpolate: options.interpolation || d3.curveLinear
        });
      }
    }

    return this;
  };

  SimpleGraph.prototype._getPointLine = function (points, handleOverlap) {
    points.sort(function (a, b) {
      return a.x - b.x;
    });
    var lineCoords = [];

    for (var i = 0; i < points.length; ++i) {
      var p = points[i],
          ys = [p.y],
          coords = [p.x, p.y],
          overlaps = false; // accumlate overlaps

      while (i + 1 < points.length) {
        p = points[i + 1];

        if (p.x === coords[0]) {
          overlaps = true;
          ys.push(p.y);
          ++i;
        } else {
          // assuming sorted, so all equal values should be consequtive
          break;
        }
      } // add next line coordinate, processing overlaps as necessary


      if (overlaps) {
        if (~["mean", "average"].indexOf(handleOverlap)) {
          coords[1] = ys.reduce(function (a, v) {
            return a + v;
          });
        } else {
          ys.sort();

          switch (handleOverlap) {
            case "lowest":
            case "min":
              coords[1] = ys[0];
              break;

            case "highest":
            case "max":
              coords[1] = ys[ys.length - 1];
              break;

            case "median":
              coords[1] = ys[Math.floor(0.5 * ys.length)];
              break;

            default:
              throw "Unknown handle overlap operation: ".concat(handleOverlap);
          }
        }
      }

      lineCoords.push(coords);
    }

    return lineCoords;
  };

  SimpleGraph.prototype.clearLinesData = function (series) {
    if (!series) {
      this.lines = null;
    } else {
      this.lines = this.lines.filter(function (d) {
        return d.series !== series;
      });
    }

    return this;
  };

  SimpleGraph.prototype.clearPointLinesData = function (series) {
    if (!series) {
      this.pointLines = null;
    } else {
      this.pointLines = pointLines.lines.filter(function (d) {
        return d.series !== series;
      });
    }

    return this;
  };

  SimpleGraph.prototype.getLinesDataBySeries = function (series) {
    if (!this.lines) return [];
    return this.lines.filter(function (d) {
      return d.series === series;
    }).map(function (d) {
      return {
        series: d.series,
        lineFunction: d.lineFunction,
        coords: d.coords.map(function (c) {
          return sg_data_line_toConsumableArray(c);
        }),
        xRange: sg_data_line_toConsumableArray(d.xRange),
        y2: d.y2,
        style: d.style,
        interpolate: d.interpolation
      };
    });
  };

  SimpleGraph.prototype.updateLineInterpolation = function (series, interpolation) {
    if (!this.lines) return this;
    this.lines.forEach(function (d) {
      if (d.series === series) d.interpolation = interpolation;
    });
    return this;
  };

  SimpleGraph.prototype.updateLinesData = function () {
    if (!this.lines) return this;
    this.lines.forEach(function (d) {
      if (d._bind.xRange) {
        d.xRange = sg_data_line_toConsumableArray(d._bind.xRange);
      }

      if (d._bind.coords) {
        d.coords = d._bind.coords.map(function (c) {
          return sg_data_line_toConsumableArray(c);
        });
      }
    });
    return this;
  };
});
// CONCATENATED MODULE: ./src/sg.draw.lib.js
/* harmony default export */ var sg_draw_lib = (function (SimpleGraph) {
  /*
   * Find x-intercept (on either y-axis min or max).using simple binary search
   */
  SimpleGraph.prototype._findIntercept = function (f, x1, x2, y2Axis) {
    var y1 = f(x1),
        y2 = f(x2),
        breakValue,
        increasing,
        yAxis = y2Axis ? this.y2 : this.y;

    if (y1 < yAxis.min !== y2 < yAxis.min) {
      breakValue = yAxis.min;
    } else if (y1 > yAxis.max !== y2 > yAxis.max) {
      breakValue = yAxis.max;
    } else {
      return null;
    }

    var x = x1 + 0.5 * (x2 - x1),
        // start halfway
    search = 0.25 * Math.abs(x2 - x1),
        // search distance
    lasty = y1,
        lastx = x1,
        // store last x,y values
    y,
        diff,
        goHigher,
        // vars scoped only in interation but to avoid redeclaring var
    lastDiff,
        lastGoHigher; // some other memory items

    x1 -= 0.00001; // tolerances to min/max bounds as binary conversion be funky

    x2 += 0.00001; // minor discrepancies when converted to decimal values

    var i = 0; // increment for fail-safe stop condition

    while (i++ < 100) {
      y = f(x);
      diff = Math.abs(y - breakValue);

      if (x >= this.x.min && x <= this.x.max && diff < 0.000001) {
        return [x, breakValue];
      }

      if (i > 0 && lastDiff < diff) {
        // last search point was closer
        x = lastx;
        y = lasty;
        search *= 0.5;
      } else {
        // new search point is closer (determine whether to try higher/lower x by comparing whether the y 
        // is over the break value against whether the line is upsloped).
        goHigher = y > breakValue !== (x > lastx === y > lasty);

        if (goHigher !== lastGoHigher) {
          search *= 0.5;
        }

        lastx = x;
        lasty = y;
        lastGoHigher = goHigher;
        lastDiff = diff;
      }

      x += lastGoHigher ? search : -search;
      if (x < x1 || x > x2) return null;
    }

    return null;
  };
  /*
   * Split line into segments based on it crossing in/out of the graph bounds. This version works on line coordinates, traversing through coordinates and tracking as it enters or leaves domain.
   */


  SimpleGraph.prototype._getLineSegmentsFromCoordinates = function (lineCoords, y2Axis) {
    var yAxis = y2Axis ? this.y2 : this.y,
        segments = [],
        segment = [],
        lastCoords = null,
        crossedXMin = false,
        crossedXMax = false;

    for (var c = 0; c < lineCoords.length; c++) {
      var coords = lineCoords[c]; // null means a break in the line

      if (coords[1] === undefined || coords[1] === null) {
        if (segment.length > 1) segments.push(segment);
        segment = [];
        lastCoords = null;
        continue;
      } // note, if date, this will become y per milliseconds


      var slope = !lastCoords ? 0 : (lineCoords[c][1] - lastCoords[1]) / (lineCoords[c][0] - lastCoords[0]); // search for x-domain crossings, if it hasn't yet entered graph area

      if (!crossedXMin) {
        if (coords[0] >= this.x.min) {
          crossedXMin = true;

          if (coords[0] > this.x.min && lastCoords) {
            // get y-intercept on x-domain-min, add if within range
            var intercept = [this.x.min, lastCoords[0] + slope * (coords[1] - lastCoords[1])];

            if (intercept[1] >= yAxis.min && intercept[1] <= yAxis.max) {
              segment.push(intercept);
            }
          } // add if within y-range


          if (coords[1] >= yAxis.min && coords[1] <= yAxis.max) {
            segment.push(coords);
          }
        } // skip rest of loop until crossing x-domain or because we just added segment start


        lastCoords = coords;
        continue;
      }

      if (!crossedXMax && coords[0] >= this.x.max) {
        crossedXMax = true;

        if (coords[0] > this.x.max) {
          // if no last coords, this is just a point outside
          if (!lastCoords) break; // interpolate back to x-max

          coords = [this.x.max, lastCoords[0] + slope * (coords[1] - lastCoords[1])];
        }
      } // check within y-domain, if inside, add to running segment, if outside, end segment


      if (coords[1] >= yAxis.min && coords[1] <= yAxis.max) {
        // SPECIAL CASE: first point of new segment
        if (segment.length === 0 && lastCoords) {
          if (slope !== 0) {
            // get y-intercept
            var yTarget = slope > 0 ? yAxis.min : yAxis.max;
            var lastX = this.x.isDate ? lastCoords[0].getTime() : lastCoords[0];
            coords = [lastX + (yTarget - lastCoords[1]) / slope, yTarget];
            if (this.x.isDate) coords[0] = new Date(coords[0]); // force repeat of the coords that original came in for this loop (intercept will become last)

            c--;
          }
        } // add to segment


        segment.push(coords);
      } else {
        // SPECIAL CASE: ending segment with last point outside of range
        if (segment.length > 0) {
          // yet y-intercept
          var yTarget = slope > 0 ? yAxis.max : yAxis.min;
          var lastX = this.x.isDate ? lastCoords[0].getTime() : lastCoords[0];
          coords = [lastX + (yTarget - lastCoords[1]) / slope, yTarget];
          if (this.x.isDate) coords[0] = new Date(coords[0]); // add to segment

          segment.push(coords);
        } // finish segment


        if (segment.length > 1) {
          segments.push(segment);
          segment = [];
        }
      } // if crossed x-max we can break


      if (crossedXMax) break; // save last coordinates

      lastCoords = coords;
    } // always add last segment (if valid)


    if (segment.length > 1) segments.push(segment);
    return segments;
  };
  /*
   * Split line into segments based on it crossing in/out of the graph bounds. This version works on line as function, traversing through coordinates by resolution and tracking as it enters or leaves domain.
   */


  SimpleGraph.prototype._getLineSegmentsFromFunction = function (lineFunction, resolution, xRange, y2Axis, limitToGraphRange) {
    if (!xRange) {
      xRange = [this.x.min, this.x.max];
    } else {
      if (xRange[0] < this.x.min) {
        xRange[0] = this.x.min;
      }

      if (xRange[1] > this.x.max) {
        xRange[0] = this.x.max;
      }
    }

    if (!resolution || typeof resolution !== "number") {
      resolution = Math.floor((this.width - this.margins.left - this.margins.right) / 10);
    }

    if (resolution < 2) resolution = 2; // how increments down the line are handled

    var incrementFunc;

    if (!this.x.isLog) {
      // if not log-scale, standard increment (this works for dates too)
      var increment = (xRange[1] - xRange[0]) / (resolution - 1),
          isDate = this.x.isDate; // standard increment function

      incrementFunc = function incrementFunc(n) {
        return isDate ? new DateUTC(n.getTime() + increment) : n + increment;
      };
    } else {
      // increment in exponential scale fit to range and resolution
      var base = Math.pow(xRange[1] / xRange[0], 1 - resolution);

      incrementFunc = function incrementFunc(n) {
        n *= base;
        return n > xRange[1] ? xRange[1] : n;
      };
    }

    var segments = [],
        segment = [],
        x = xRange[0],
        lastX = x,
        yAxis = y2Axis ? this.y2 : this.y;

    while (true) {
      var markForBreak = false;

      if (x >= xRange[1]) {
        x = xRange[1];
        markForBreak = true;
      }

      var y = lineFunction(x);

      if (!limitToGraphRange) {
        segment.push([x, y]);
        continue;
      }

      if (y >= yAxis.min && y <= yAxis.max) {
        // case: first point of new segment
        if (segment.length === 0 && x > xRange[0]) {
          // get y-intercept
          var intercept = this._findIntercept(lineFunction, lastX, x, y2Axis);

          if (intercept) {
            segment.push(intercept);
          }
        } // add to segment


        segment.push([x, y]);
      } else {
        // case: ending segment with last point outside of range
        if (segment.length > 0) {
          // yet y-intercept
          var intercept = this._findIntercept(lineFunction, lastX, x, y2Axis);

          if (intercept) {
            segment.push(intercept);
          }
        } // finish segment


        if (segment.length > 1) {
          segments.push(segment);
          segment = [];
        }
      }

      lastX = x;
      x = incrementFunc(x);
      if (markForBreak) break;
    } // always attempt to add last segment


    if (segment.length > 1) segments.push(segment);
    return segments;
  };

  SimpleGraph.prototype._getAreaPolysFromCoordinates = function (areaCoordinates, y2Axis) {
    var lineA = [],
        lineB = [];

    for (var i = 0; i < areaCoordinates.length; i++) {
      lineA.push([areaCoordinates[i][0], areaCoordinates[i][1]]);
      lineB.push([areaCoordinates[i][0], areaCoordinates[i][2]]);
    }

    return this._getAreaPolysFromLineCrosswalk(this._getLineSegmentsFromCoordinates(lineA, y2Axis), this._getLineSegmentsFromCoordinates(lineB, y2Axis), y2Axis);
  };

  SimpleGraph.prototype._getAreasPolysFromFunctions = function (funcA, funcB, resolution, xRange, y2Axis, limitToGraphRange) {
    var lines = [this._getLineSegmentsFromFunction(funcA, resolution, xRange, y2Axis, limitToGraphRange), this._getLineSegmentsFromFunction(funcB, resolution, xRange, y2Axis, limitToGraphRange)];
    return this._getAreaPolysFromLineCrosswalk(this._getLineSegmentsFromFunction(funcA, resolution, xRange, y2Axis, limitToGraphRange), this._getLineSegmentsFromFunction(funcB, resolution, xRange, y2Axis, limitToGraphRange), y2Axis);
  };

  SimpleGraph.prototype._getAreaPolysFromLineCrosswalk = function (lineA, lineB, y2Axis) {
    var areas = [],
        areaCoords = [],
        li = [0, 0],
        ci = [0, 0],
        endOfLines = [false, false],
        endOfCoords = [false, false],
        coordA,
        coordB;

    while (true) {
      // grab coords
      coordA = endOfLines[0] ? null : lineA[li[0]][ci[0]];
      coordB = endOfLines[1] ? null : lineB[li[1]][ci[1]]; // whether to progress each line

      var moveCoords = [false, false];

      if (!coordA && !coordB) {
        break;
      } else if (!coordA || !coordB) {
        // if null value in either coordinate or odd situation if inconsistent number of coordinates, 
        // pinch off area and move
        moveCoords = [true, true];

        if (areaCoords.length >= 2) {
          areas.push(areaCoords);
        }

        areaCoords = [];
      } else if (coordA[0] === coordB[0]) {
        // matching, just add
        areaCoords.push([coordA[0], coordA[1], coordB[1]]); // both coords moved

        moveCoords[0] = moveCoords[1] = true;
      } else {
        // if one set of coords needs to catch up, don't add the coord (assume no area), pinch existing 
        // coords to areas if available
        if (coordA[0] < coordB[0]) {
          moveCoords[0] = true;
        } else {
          moveCoords[1] = true;
        }

        if (areaCoords.length >= 2) {
          areas.push(areaCoords);
        }

        areaCoords = [];
      }

      var newLines = [false, false];

      for (var i = 0; i < 2; i++) {
        if (endOfLines[i]) {
          continue;
        }

        var line = i === 0 ? lineA : lineB; // move coords as necessary

        if (moveCoords[i]) {
          ci[i] += 1;
        } // check end of coordinates


        endOfCoords[i] = ci[i] >= line[li[i]].length; // increment lines when needed

        if (endOfCoords[i]) {
          li[i] += 1;
          ci[i] = 0;
          newLines[i] = true; // check end of line

          endOfLines[i] = li[i] >= line.length;
        }
      } // if both moved to new lines, we can pinch off this area and start a new one


      if (newLines[0] && newLines[1]) {
        if (areaCoords.length >= 2) {
          areas.push(areaCoords);
        }

        areaCoords = [];
      } // break condition


      if (endOfLines[0] && endOfLines[1]) {
        if (areaCoords.length >= 2) {
          areas.push(areaCoords);
        }

        break;
      }
    }

    return areas;
  };
});
// CONCATENATED MODULE: ./src/sg.draw.points.js
function sg_draw_points_toConsumableArray(arr) { return sg_draw_points_arrayWithoutHoles(arr) || sg_draw_points_iterableToArray(arr) || sg_draw_points_unsupportedIterableToArray(arr) || sg_draw_points_nonIterableSpread(); }

function sg_draw_points_nonIterableSpread() { throw new TypeError("Invalid attempt to spread non-iterable instance.\nIn order to be iterable, non-array objects must have a [Symbol.iterator]() method."); }

function sg_draw_points_unsupportedIterableToArray(o, minLen) { if (!o) return; if (typeof o === "string") return sg_draw_points_arrayLikeToArray(o, minLen); var n = Object.prototype.toString.call(o).slice(8, -1); if (n === "Object" && o.constructor) n = o.constructor.name; if (n === "Map" || n === "Set") return Array.from(o); if (n === "Arguments" || /^(?:Ui|I)nt(?:8|16|32)(?:Clamped)?Array$/.test(n)) return sg_draw_points_arrayLikeToArray(o, minLen); }

function sg_draw_points_iterableToArray(iter) { if (typeof Symbol !== "undefined" && Symbol.iterator in Object(iter)) return Array.from(iter); }

function sg_draw_points_arrayWithoutHoles(arr) { if (Array.isArray(arr)) return sg_draw_points_arrayLikeToArray(arr); }

function sg_draw_points_arrayLikeToArray(arr, len) { if (len == null || len > arr.length) len = arr.length; for (var i = 0, arr2 = new Array(len); i < len; i++) { arr2[i] = arr[i]; } return arr2; }


/* harmony default export */ var sg_draw_points = (function (SimpleGraph, d3) {
  SimpleGraph.prototype.removePoints = function () {
    this.svgGraph.selectAll(".sg-point").remove();
    return this;
  };

  SimpleGraph.prototype.drawPoints = function (showNulls) {
    this.removePoints();
    if (!this.points || this.points.length === 0) return this;
    var self = this,
        drawPointsData = this.points; // if necessary, remove points that extend beyond graph

    if (!this.allowDrawBeyondGraph) {
      drawPointsData = drawPointsData.filter(function (d) {
        if (!d.x && d.x !== 0 || Number.isNaN(d.x)) return false;
        if (d.x < self.x.min || d.x > self.x.max) return false;
        if (self.x["break"] && d.x > self.x["break"].domain[0] && d.x < self.x["break"].domain[1]) return false;
        if (!d.y && d.y !== 0 || Number.isNaN(d.y) && !showNulls) return false;
        var yAxis = d.y2 ? self.y2 : self.y;
        if (d.y < yAxis.min || d.y > yAxis.max) return false;
        if (yAxis["break"] && d.y > yAxis["break"].domain[0] && d.y < yAxis["break"].domain[1]) return false;
        return true;
      });
    }

    if (!drawPointsData.length) return this;
    var pointsDataBySeries = {};
    drawPointsData.forEach(function (d) {
      if (!(d.series in pointsDataBySeries)) {
        pointsDataBySeries[d.series] = [d];
      } else {
        pointsDataBySeries[d.series].push(d);
      }
    });

    for (var series in pointsDataBySeries) {
      this._drawPoints(this.svgGraph.selectAll(".sg-temporary-point").data(pointsDataBySeries[series]).enter(), this.ptSeriesShapes[series]);
    }

    return this;
  };

  SimpleGraph.prototype.updatePoints = function (showNulls, transition) {
    var _this = this;

    if (!this.points || this.points.length === 0) {
      this.removePoints();
      this.removePointLines();
      return this;
    }

    if (transition) {
      transition.duration = transition.duration || 200;
      transition.ease = transition.ease || d3.easePolyOut;
    }

    var drawPointsData = this.points; // if necessary, remove points that extend beyond graph

    if (!this.allowDrawBeyondGraph) {
      drawPointsData = drawPointsData.filter(function (d) {
        if (!d.x && d.x !== 0 || Number.isNaN(d.x)) return false;
        if (d.x < self.x.min || d.x > self.x.max) return false;
        if (self.x["break"] && d.x > self.x["break"].domain[0] && d.x < self.x["break"].domain[1]) return false;
        if (!d.y && d.y !== 0 || Number.isNaN(d.y) && !showNulls) return false;
        var yAxis = d.y2 ? self.y2 : self.y;
        if (d.y < yAxis.min || d.y > yAxis.max) return false;
        if (yAxis["break"] && d.y > yAxis["break"].domain[0] && d.y < yAxis["break"].domain[1]) return false;
        return true;
      });
    }

    var pointsDataBySeries = {};
    drawPointsData.forEach(function (d) {
      if (!(d.series in pointsDataBySeries)) {
        pointsDataBySeries[d.series] = [d];
      } else {
        pointsDataBySeries[d.series].push(d);
      }
    });

    var _loop = function _loop(series) {
      data = pointsDataBySeries[series];
      shape = _this.ptSeriesShapes[series];
      selection = _this.svgGraph.selectAll(".sg-point").filter(function (d) {
        return d.series === series;
      }); // remove points that no longer exist and reselect (for those that will need modifying)

      selection.filter(function (d) {
        return !~data.indexOf(d);
      }).remove();
      selection = selection.filter(function (d) {
        return ~data.indexOf(d);
      }); // update existing points

      _this._updatePoints(selection, shape, transition); // add new points


      newData = sg_draw_points_toConsumableArray(data);
      selection.forEach(function (d) {
        var exists = newData.indexOf(d);
        if (~exists) newData.splice(exists, 1);
      });

      _this._drawPoints(_this.svgGraph.selectAll(".sg-temporary-point").data(newData).enter(), shape, transition);
    };

    for (var series in pointsDataBySeries) {
      var data, shape, selection;
      var newData;

      _loop(series);
    }

    return this;
  };

  SimpleGraph.prototype._drawPoints = function (selection, shape, transition) {
    if (!selection.size()) return;
    var self = this,
        items;

    switch (shape) {
      case "triangle-down":
        items = selection.append("polygon").attr("series", function (d) {
          return d.series;
        }).attr("opacity", transition ? 0 : 1).attr("class", "sg-point sg-point-td").attr("points", function (d) {
          var size = size = typeof d.size === "function" ? d.size() : d.size,
              length = size * 1.519676,
              // side length of equilateral trangle of same area of square
          height = length * 0.86602,
              // ratio of equilateral triangle
          hh = 0.5 * height,
              hl = 0.5 * length,
              x = self.x.scale(d.x),
              y = !d.y && d.y !== 0 || Number.isNaN(d.y) ? 0 : d.y;
          y = (d.y2 ? self.y2.scale : self.y.scale)(y);
          return "".concat(x - hl, ",").concat(y + hh, " ").concat(x, ",").concat(y - hh, " ").concat(x + hl, ",").concat(y + hh);
        }).style("fill", function (d) {
          return d.wasNull ? "none" : self.getColorBySeriesName(d.series, true);
        }).style("stroke", function (d) {
          return !d.wasNull ? null : self.getColorBySeriesName(d.series, true);
        });
        break;

      case "triangle":
      case "triangle-up":
        items = selection.append("polygon").attr("series", function (d) {
          return d.series;
        }).attr("opacity", transition ? 0 : 1).attr("class", "sg-point sg-point-tu").attr("points", function (d) {
          var size = size = typeof d.size === "function" ? d.size(d, d._bind) : d.size,
              length = size * 1.519676,
              // side length of equilateral trangle of same area of square
          height = length * 0.86602,
              // ratio of equilateral triangle
          hh = 0.5 * height,
              hl = 0.5 * length,
              x = self.x.scale(d.x),
              y = !d.y && d.y !== 0 || Number.isNaN(d.y) ? 0 : d.y;
          y = (d.y2 ? self.y2.scale : self.y.scale)(y);
          return "".concat(x - hl, ",").concat(y - hh, " ").concat(x, ",").concat(y + hh, " ").concat(x + hl, ",").concat(y - hh);
        }).style("fill", function (d) {
          return d.wasNull ? "none" : self.getColorBySeriesName(d.series, true);
        }).style("stroke", function (d) {
          return !d.wasNull ? null : self.getColorBySeriesName(d.series, true);
        });
        break;

      case "square":
      case "diamond":
        items = selection.append("rect").attr("opacity", transition ? 0 : 1).attr("series", function (d) {
          return d.series;
        }).attr("class", "sg-point sg-point-sd").attr("width", function (d) {
          return typeof d.size === "function" ? d.size() : d.size;
        }).attr("height", function (d) {
          return typeof d.size === "function" ? d.size() : d.size;
        }).attr("x", function (d) {
          var size = typeof d.size === "function" ? d.size() : d.size;
          return self.x.scale(d.x) - size / 2.0;
        }).attr("y", function (d) {
          var y = !d.y && d.y !== 0 || Number.isNaN(d.y) ? 0 : d.y,
              size = typeof d.size === "function" ? d.size() : d.size;
          return (d.y2 ? self.y2.scale : self.y.scale)(d.y) - size / 2.0;
        }).attr("transform", function (d) {
          if (shape !== "diamond") return "";
          var y = !d.y && d.y !== 0 || Number.isNaN(d.y) ? 0 : d.y;
          return "rotate(45,".concat(self.x.scale(d.x), ",").concat((d.y2 ? self.y2.scale : self.y.scale)(y), ")");
        }).style("fill", function (d) {
          return d.wasNull ? "none" : self.getColorBySeriesName(d.series, true);
        }).style("stroke", function (d) {
          return !d.wasNull ? null : self.getColorBySeriesName(d.series, true);
        });
        break;

      default:
      case "circle":
        items = selection.append("circle").attr("opacity", transition ? 0 : 1).attr("series", function (d) {
          return d.series;
        }).attr("class", "sg-point sg-point-cr").attr("r", function (d) {
          return 0.5 * (typeof d.size === "function" ? d.size(d, d._bind) : d.size);
        }).attr("cx", function (d) {
          return self.x.scale(d.x);
        }).attr("cy", function (d) {
          var y = !d.y && d.y !== 0 || Number.isNaN(d.y) ? 0 : d.y;
          return (d.y2 ? self.y2.scale : self.y.scale)(y);
        }).style("fill", function (d) {
          return d.wasNull ? "none" : self.getColorBySeriesName(d.series, true);
        }).style("stroke", function (d) {
          return !d.wasNull ? null : self.getColorBySeriesName(d.series, true);
        });
        break;
    }

    if (transition) {
      items.transition().duration(transition.duration).ease(transition.ease).attr("opacity", 1.0);
    }
  };

  SimpleGraph.prototype._updatePoints = function (selection, shape, transition) {
    if (!selection.size()) return;

    if (transition) {
      selection = selection.transition().duration(transition.duration).ease(transition.ease);
    }

    var self = this;

    switch (shape) {
      case "triangle-down":
        selection.attr("points", function (d) {
          var size = size = typeof d.size === "function" ? d.size(d, d._bind) : d.size,
              length = size * 1.519676,
              // side length of equilateral trangle of same area of square
          height = length * 0.86602,
              // ratio of equilateral triangle
          hh = 0.5 * height,
              hl = 0.5 * length,
              x = self.x.scale(d.x),
              y = !d.y && d.y !== 0 || Number.isNaN(d.y) ? 0 : d.y;
          y = (d.y2 ? self.y2.scale : self.y.scale)(y);
          return "".concat(x - hl, ",").concat(y + hh, " ").concat(x, ",").concat(y - hh, " ").concat(x + hl, ",").concat(y + hh);
        }).style("fill", function (d) {
          return d.wasNull ? "none" : self.getColorBySeriesName(d.series, true);
        }).style("stroke", function (d) {
          return !d.wasNull ? null : self.getColorBySeriesName(d.series, true);
        });
        break;

      case "triangle":
      case "triangle-up":
        selection.attr("points", function (d) {
          var size = size = typeof d.size === "function" ? d.size(d, d._bind) : d.size,
              length = size * 1.519676,
              // side length of equilateral trangle of same area of square
          height = length * 0.86602,
              // ratio of equilateral triangle
          hh = 0.5 * height,
              hl = 0.5 * length,
              x = self.x.scale(d.x),
              y = !d.y && d.y !== 0 || Number.isNaN(d.y) ? 0 : d.y;
          y = (d.y2 ? self.y2.scale : self.y.scale)(y);
          return "".concat(x - hl, ",").concat(y - hh, " ").concat(x, ",").concat(y + hh, " ").concat(x + hl, ",").concat(y - hh);
        }).style("fill", function (d) {
          return d.wasNull ? "none" : self.getColorBySeriesName(d.series, true);
        }).style("stroke", function (d) {
          return !d.wasNull ? null : self.getColorBySeriesName(d.series, true);
        });
        break;

      case "square":
      case "diamond":
        selection.attr("width", function (d) {
          return typeof d.size === "function" ? d.size(d, d._bind) : d.size;
        }).attr("height", function (d) {
          return typeof d.size === "function" ? d.size(d, d._bind) : d.size;
        }).attr("x", function (d) {
          var size = typeof d.size === "function" ? d.size(d, d._bind) : d.size;
          return self.x.scale(d.x) - size / 2.0;
        }).attr("y", function (d) {
          var y = !d.y && d.y !== 0 || Number.isNaN(d.y) ? 0 : d.y,
              size = typeof d.size === "function" ? d.size(d, d._bind) : d.size;
          return (d.y2 ? self.y2.scale : self.y.scale)(d.y) - size / 2.0;
        }).attr("transform", function (d) {
          if (shape !== "diamond") return "";
          var y = !d.y && d.y !== 0 || Number.isNaN(d.y) ? 0 : d.y;
          return "rotate(45,".concat(self.x.scale(d.x), ",").concat((d.y2 ? self.y2.scale : self.y.scale)(y), ")");
        }).style("fill", function (d) {
          return d.wasNull ? "none" : self.getColorBySeriesName(d.series, true);
        }).style("stroke", function (d) {
          return !d.wasNull ? null : self.getColorBySeriesName(d.series, true);
        });
        break;

      default:
      case "circle":
        selection.attr("r", function (d) {
          return 0.5 * (typeof d.size === "function" ? d.size(d, d._bind) : d.size);
        }).attr("cx", function (d) {
          return self.x.scale(d.x);
        }).attr("cy", function (d) {
          var y = !d.y && d.y !== 0 || Number.isNaN(d.y) ? 0 : d.y;
          return (d.y2 ? self.y2.scale : self.y.scale)(y);
        }).style("fill", function (d) {
          return d.wasNull ? "none" : self.getColorBySeriesName(d.series, true);
        }).style("stroke", function (d) {
          return !d.wasNull ? null : self.getColorBySeriesName(d.series, true);
        });
        break;
    }
  };
});
// CONCATENATED MODULE: ./src/sg.draw.lines.js

/* harmony default export */ var sg_draw_lines = (function (SimpleGraph, d3) {
  SimpleGraph.prototype.removeAllLines = function () {
    return this.removeLines().removePointLines();
  };

  SimpleGraph.prototype.removeLines = function () {
    this.svgGraph.selectAll(".sg-line").remove();
    if (this.lines) this.lines.forEach(function (d) {
      return d._d3s = null;
    });
    return this;
  };

  SimpleGraph.prototype.removePointLines = function () {
    this.svgGraph.selectAll(".sg-point-line").remove();
    if (this.pointLines) this.pointLines.forEach(function (d) {
      return d._d3s = null;
    });
    return this;
  };

  SimpleGraph.prototype.drawAllLines = function (resolution) {
    return this.drawPointLines().drawLines(resolution);
  };

  SimpleGraph.prototype.drawLines = function (resolution) {
    this.removeLines(); // default and enforced minimum resolution for resolving from function

    if (!resolution && resolution !== 0) resolution = 20;
    if (resolution == 0 || resolution < 2) resolution = 2;
    if (!this.lines) return this;
    var self = this;
    this.lines.forEach(function (line) {
      if (line.lineFunction) {
        line._segments = self._getLineSegmentsFromFunction(line.lineFunction, resolution, line.xRange, line.y2Axis, !self.allowDrawBeyondGraph);
      } else if (self.allowDrawBeyondGraph) {
        line._segments = [line.coords];
      } else {
        line._segments = self._getLineSegmentsFromCoordinates(line.coords, line.y2);
      }

      if (line._segments) line._segments = line._segments.filter(function (s) {
        return s && s.length >= 2;
      });
    });

    this._drawLines(this.lines, "sg-line");

    return this;
  };

  SimpleGraph.prototype.drawPointLines = function () {
    this.removePointLines();
    if (!this.pointLines) return this;
    var self = this;
    this.pointLines.forEach(function (line) {
      if (self.allowDrawBeyondGraph) {
        line._segments = [line.coords];
      } else {
        line._segments = self._getLineSegmentsFromCoordinates(line.coords, line.y2);
      }

      if (line._segments) line._segments = line._segments.filter(function (s) {
        return s && s.length >= 2;
      });
    });

    this._drawLines(this.pointLines, "sg-point-line");

    return this;
  };

  SimpleGraph.prototype.updateAllLines = function (resolution, transition) {
    return this.updateLines(resolution, transition).updatePointLines(transition);
  };

  SimpleGraph.prototype.updateLines = function (resolution, transition) {
    // defaults
    if (!resolution && resolution !== 0) resolution = 20;
    if (resolution == 0 || resolution < 2) resolution = 2;

    if (transition) {
      transition.duration = transition.duration || 200;
      transition.ease = transition.ease || d3.easePolyOut;
    }

    var self = this;
    this.lines.forEach(function (line) {
      if (line.lineFunction) {
        line._segments = self._getLineSegmentsFromFunction(line.lineFunction, resolution, line.xRange, line.y2Axis, !self.allowDrawBeyondGraph);
      } else if (self.allowDrawBeyondGraph) {
        line._segments = [line.coords];
      } else {
        line._segments = self._getLineSegmentsFromCoordinates(line.coords, line.y2);
      }

      if (line._segments) line._segments = line._segments.filter(function (s) {
        return s && s.length >= 2;
      });
    });

    self._updateLines(this.lines, "sg-line", transition);

    return this;
  };

  SimpleGraph.prototype.updatePointLines = function (transition) {
    // defaults
    if (transition) {
      transition.duration = transition.duration || 200;
      transition.ease = transition.ease || d3.easePolyOut;
    }

    var self = this;
    this.pointLines.forEach(function (line) {
      if (self.allowDrawBeyondGraph) {
        line._segments = [line.coords];
      } else {
        line._segments = self._getLineSegmentsFromCoordinates(line.coords, line.y2);
      }

      if (line._segments) line._segments = line._segments.filter(function (s) {
        return s && s.length >= 2;
      });
    });

    self._updateLines(this.pointLines, "sg-point-line", transition);

    return this;
  };

  SimpleGraph.prototype._drawLines = function (lines, className, transition) {
    var self = this,
        addedLines = this.svgGraph.selectAll(".sg-temporary-line").data(lines).enter().append("path").attr("series", function (d) {
      return d.series;
    }).attr("class", className).attr("opacity", transition ? 0 : 1).style("fill", 'none').attr("d", function (d) {
      var yAxis = d.y2 ? self.y2 : self.y,
          d3line = d3.line().x(function (c) {
        return self.x.scale(c[0]);
      }).y(function (c) {
        return yAxis.scale(c[1]);
      }).curve(d.interpolate);
      return d._segments.reduce(function (path, segment) {
        return (path || "") + (segment.length < 2 ? "" : " " + d3line(segment));
      }, "");
    }).each(function (d) {
      // add styles
      var nLine = d3.select(this),
          styles = d.style || {};

      for (var key in styles) {
        nLine.style(key, styles[key]);
      } // add color if not specified


      if (!('stroke' in styles)) {
        nLine.style('stroke', self.getColorBySeriesName(d.series, true));
      } // attach


      d._d3s = nLine;
    }); // animate

    if (transition) {
      addedLines.transition().duration(transition.duration).ease(transition.ease).attr("opacity", 1.0);
    }
  };

  SimpleGraph.prototype._updateLines = function (lines, className, transition) {
    if (!lines) return this; // remove, while also filter for new lines

    lines = lines.filter(function (line) {
      if (!line._segments || !line._segments.length) {
        if (segments._d3s) {
          line._d3s.remove();

          line._d3s = null;
        }

        return false;
      }

      return !line._d3s;
    }); // modify existing lines, transition if necessary

    var sel = this.svgGraph.selectAll("." + className);

    if (transition) {
      sel = sel.transition().duration(transition.duration).ease(transition.ease);
    }

    var self = this;
    sel.attr("d", function (d) {
      var yAxis = d.y2 ? self.y2 : self.y,
          d3line = d3.line().x(function (c) {
        return self.x.scale(c[0]);
      }).y(function (c) {
        return yAxis.scale(c[1]);
      }).curve(d.interpolate);
      return d._segments.reduce(function (path, segment) {
        return (path || "") + (segment.length < 2 ? "" : " " + d3line(segment));
      }, "");
    }).each(function (d) {
      // update styles
      var nLine = d3.select(this),
          styles = d.style || {};

      for (var key in styles) {
        nLine.style(key, styles[key]);
      } // add color if not specified


      if (!('stroke' in styles)) {
        nLine.style('stroke', self.getColorBySeriesName(d.series, true));
      }
    }); // add new lines

    this._drawLines(lines, className, transition);
  };
});
// CONCATENATED MODULE: ./src/sg.draw.areas.js

/* harmony default export */ var sg_draw_areas = (function (SimpleGraph, d3) {
  SimpleGraph.prototype.drawAreas = function () {
    this.removeAreas(); // for this references

    var self = this;
    var color = this.color; // local function for adding areas to graph as it may be used multiple times per loop

    function addArea(areaData, areaCoords, className) {
      if (areaCoords.length < 2 || areaCoords[0].length < 2 || areaCoords[1].length < 2) {
        return this;
      }

      var yScale = areaData.y2 ? self.y2.scale : self.y.scale;
      var addedArea = self.svgGraph.selectAll(".sg-temporary-area").data([areaCoords]).enter().append("path").attr("series", areaData.series).attr("class", className).attr("d", d3.area().x(function (c) {
        return self.x.scale(c[0]);
      }).y0(function (c) {
        return yScale(c[1]);
      }).y1(function (c) {
        return yScale(c[2]);
      }).curve(areaData.interpolate));
      var styles = areaData.style ? areaData.style : {};

      for (var skey in styles) {
        addedArea.style(skey, styles[skey]);
      } // add color if not specified


      if (!('fill' in styles)) {
        addedArea.style("fill", self.getColorBySeriesName(areaData.series, true));
      }
    }

    if (this.areas) {
      for (var a = 0; a < this.areas.length; a++) {
        var area = this.areas[a]; // areas added as functions

        if (area.areaFunctions) {
          var areaPolys = this._getAreasPolysFromFunctions(area.areaFunctions[0], area.areaFunctions[1], area.resolution, area.xRange, area.y2, !this.allowDrawBeyondGraph);

          for (var p = 0; p < areaPolys.length; p++) {
            addArea(area, areaPolys[p], "sg-area");
          } // areas added as coordinates

        } else {
          if (this.allowDrawBeyondGraph) {
            addArea(area.coords, "sg-area");
          } else {
            var areaPolys = this._getAreaPolysFromCoordinates(area.coords, area.y2);

            for (var p = 0; p < areaPolys.length; p++) {
              addArea(area, areaPolys[p], "sg-area");
            }
          }
        }
      }
    }

    return this;
  };

  SimpleGraph.prototype.removeAreas = function () {
    this.svgGraph.selectAll(".sg-area").remove();
    return this;
  };
});
// CONCATENATED MODULE: ./src/sg.tooltip.js
/* harmony default export */ var sg_tooltip = (function (SimpleGraph, d3) {
  SimpleGraph.prototype.addTooltipToPoints = function (textFunction, forSeries, options) {
    forSeries = forSeries && !Array.isArray(forSeries) ? [forSeries] : forSeries;
    this.svgGraph.selectAll(".sg-point").filter(function (d) {
      return !forSeries || ~forSeries.indexOf(d.series);
    }).call(this._constructTooltipFunctionality(textFunction, options));
    return this;
  };

  SimpleGraph.prototype.addTooltipToLines = function (textFunction, forSeries, options) {
    forSeries = forSeries && !Array.isArray(forSeries) ? [forSeries] : forSeries;
    this.svgGraph.selectAll(".sg-line").filter(function (d) {
      return !forSeries || ~forSeries.indexOf(d.series);
    }).call(this._constructTooltipFunctionality(textFunction, options));
    return this;
  };

  SimpleGraph.prototype.addTooltipToAreas = function (textFunction, forSeries, options) {
    forSeries = forSeries && !Array.isArray(forSeries) ? [forSeries] : forSeries;
    this.svgGraph.selectAll(".sg-area").filter(function (d) {
      return !forSeries || ~forSeries.indexOf(d.series);
    }).call(this._constructTooltipFunctionality(textFunction, options));
    return this;
  };

  SimpleGraph.prototype._constructTooltipFunctionality = function (textFunction, options) {
    var gNode = this.svgGraph.node();
    return function (selection) {
      if (!selection) return null;
      if (!options) options = {};
      var d3Body = d3.select('body'),
          tooltipOffset = options.offset || [15, 15],
          // TODO: selection is no longer array-like, hides it in _groups var
      // this seems less than ideal, update/change when able
      selGroup = selection._groups[0],
          tooltipDiv;
      selection.on("mouseover.sg-tooltip", function (evt, d) {
        // set relative position of tool-tip
        var absMousePos = d3.pointer(evt, d3Body.node()),
            styles; // Check if tooltip div already exists

        if (!tooltipDiv) {
          // Clean up lost tooltips
          d3Body.selectAll('.sg-tooltip').remove(); // Append tooltip 

          tooltipDiv = d3Body.append('div');
          tooltipDiv.attr('class', 'sg-tooltip'); // full styles

          styles = {
            'position': 'absolute',
            'left': absMousePos[0] + tooltipOffset[0] + 'px',
            'top': absMousePos[1] + tooltipOffset[1] + 'px',
            'z-index': 1001,
            'background-color': '#fff',
            'border': '1px solid #777',
            'border-radius': '4px',
            'padding': '4px 6px',
            'font-family': "'Century Gothic', CenturyGothic, Geneva, AppleGothic, sans-serif",
            'font-size': '12px'
          };
        } else {
          // just update position
          styles = {
            'left': absMousePos[0] + tooltipOffset[0] + 'px',
            'top': absMousePos[1] + tooltipOffset[1] + 'px'
          };
        }

        for (var styleKey in styles) {
          tooltipDiv.style(styleKey, styles[styleKey]);
        } // add custom styles if provided


        if (options.style) {
          for (var _styleKey in options.style) {
            tooltipDiv.style(_styleKey, options.style[_styleKey]);
          }
        } // additional trigger


        if (options.mouseover) options.mouseover(d, d3.pointer(evt, gNode), selGroup, i);
      }).on('mousemove.sg-tooltip', function (evt, d, i) {
        if (tooltipDiv) {
          // Move tooltip
          var absMousePos = d3.pointer(evt, d3Body.node());
          tooltipDiv.style('left', absMousePos[0] + tooltipOffset[0] + 'px').style('top', absMousePos[1] + tooltipOffset[1] + 'px');
          var tooltipText = null;

          if (textFunction) {
            tooltipText = textFunction(d, d3.pointer(evt, gNode), selGroup, i);
          } // If no text, remove tooltip


          if (!tooltipText) {
            tooltipDiv.remove();
            tooltipDiv = null;
          } else {
            tooltipDiv.html(tooltipText);
          }
        }
      }).on("mouseout.sg-tooltip", function (evt, d) {
        // additional trigger
        if (options.mouseout) options.mouseout(d, d3.pointer(evt, gNode), selGroup, i); // Remove tooltip

        if (tooltipDiv) {
          tooltipDiv.remove();
          tooltipDiv = null;
        }
      });
    };
  };

  SimpleGraph.prototype.highlightPoints = function (series, validationCallback, size, fill, stylesDict) {
    var selectQuery = ".sg-point";

    if (series) {
      selectQuery += "[series='" + series + "']";
    }

    var self = this;
    this.svgGraph.selectAll(selectQuery).each(function (d, i, s) {
      if (validationCallback && !validationCallback(d)) return;
      var xScale = self.x.scale,
          yScale = d.y2 ? self.y2.scale : self.y.scale;

      if (!size) {
        size = d.wasNull ? 0 : typeof d.pointsize === "function" ? d.pointsize() : d.pointsize;
      }

      ;

      if (!fill) {
        fill = d.wasNull ? "none" : self.getColorBySeriesName(d.series, true);
      }

      ;
      var realSize = size ? size : d.pointsize;

      if (typeof realSize === "function") {
        realSize = realSize.call(d);
      }

      var rect = self.svgGraph.append("rect").attr("class", "sg-point-highlight").attr("width", realSize).attr("height", realSize).attr("x", xScale(d.x) - realSize / 2.0).attr("y", yScale(d.y) - realSize / 2.0).attr("transform", "rotate(45," + xScale(d.x) + "," + yScale(d.y) + ")").style("fill", fill);

      if (stylesDict) {
        for (var sKey in stylesDict) {
          rect.style(sKey, stylesDict[sKey]);
        }
      }
    });
    return this;
  };

  SimpleGraph.prototype.removeHighlightPoints = function () {
    this.svgGraph.selectAll(".sg-point-highlight").remove();
    return this;
  };

  SimpleGraph.prototype.removeHighlights = function () {
    this.removeHighlightPoints();
    return this;
  };
});
// CONCATENATED MODULE: ./src/sg.highlight.js
/* harmony default export */ var sg_highlight = (function (SimpleGraph, d3) {
  SimpleGraph.prototype.highlightPoints = function (series, validationCallback, size, fill, stylesDict) {
    var selectQuery = ".sg-point";

    if (series) {
      selectQuery += "[series='" + series + "']";
    }

    var self = this;
    this.svgGraph.selectAll(selectQuery).each(function (d, i, s) {
      if (validationCallback && !validationCallback(d)) return;
      var xScale = self.x.scale,
          yScale = d.y2 ? self.y2.scale : self.y.scale;

      if (!size) {
        size = d.wasNull ? 0 : typeof d.pointsize === "function" ? d.pointsize() : d.pointsize;
      }

      ;

      if (!fill) {
        fill = d.wasNull ? "none" : self.getColorBySeriesName(d.series, true);
      }

      ;
      var realSize = size ? size : d.pointsize;

      if (typeof realSize === "function") {
        realSize = realSize.call(d);
      }

      var rect = self.svgGraph.append("rect").attr("class", "sg-point-highlight").attr("width", realSize).attr("height", realSize).attr("x", xScale(d.x) - realSize / 2.0).attr("y", yScale(d.y) - realSize / 2.0).attr("transform", "rotate(45," + xScale(d.x) + "," + yScale(d.y) + ")").style("fill", fill);

      if (stylesDict) {
        for (var sKey in stylesDict) {
          rect.style(sKey, stylesDict[sKey]);
        }
      }
    });
    return this;
  };

  SimpleGraph.prototype.removeHighlightPoints = function () {
    this.svgGraph.selectAll(".sg-point-highlight").remove();
    return this;
  };

  SimpleGraph.prototype.removeHighlights = function () {
    this.removeHighlightPoints();
    return this;
  };
});
// CONCATENATED MODULE: ./src/simple-graph.js
/*************************************************************************************************************
 * D3-Simple-Graph
 * @author Lawrence Sim
 * @copyright 2020 - San Francisco Estuary Institute
 * @license This project is licensed under the GNU Lesser General Public License.
 ************************************************************************************************************/


function simple_graph_SimpleGraph(options) {
  // default options
  if (!options) {
    options = {};
  }

  if (!options.container) {
    options.container = "body";
  }

  if (!options.margins) {
    options.margins = {};
  }

  if (!options.axis) {
    options.axis = {};
  }

  if (!options.styles) {
    options.styles = {};
  }

  if (!options.styles["font-size"]) {
    options.styles["font-size"] = "1.0em";
  } // Option to allow drawing outside graph range.


  this.allowDrawBeyondGraph = options.allowDrawBeyondGraph; // adjust width and height by margins

  this.margins = {
    left: !options.margins.left && options.margins.left !== 0 ? 40 : options.margins.left,
    right: !options.margins.right && options.margins.right !== 0 ? 20 : options.margins.right,
    top: !options.margins.top && options.margins.top !== 0 ? 20 : options.margins.top,
    bottom: !options.margins.bottom && options.margins.bottom !== 0 ? 40 : options.margins.bottom
  };
  this.containerWidth = options.width ? options.width : 600;
  this.containerHeight = options.height ? options.height : 400;
  this.width = this.containerWidth - this.margins.left - this.margins.right;
  this.height = this.containerHeight - this.margins.top - this.margins.bottom; // category color scale

  this.color = options.colorScale ? options.colorScale : external_amd_d3_root_d3_commonjs_d3_commonjs2_d3_["scaleOrdinal"](external_amd_d3_root_d3_commonjs_d3_commonjs2_d3_["schemeCategory10"]);
  this.customColors = {}; // create the SVG

  this.svg = external_amd_d3_root_d3_commonjs_d3_commonjs2_d3_["select"](options.container).append("svg").attr("width", this.containerWidth).attr("height", this.containerHeight).style('font-family', "'Century Gothic', CenturyGothic, Geneva, AppleGothic, sans-serif").style('overflow', 'visible');
  this.svgGraph = this.svg.append("g").attr("transform", "translate(" + this.margins.left + "," + this.margins.top + ")"); // append styles, save to instance the default text-size

  for (var style in options.styles) {
    this.svg.style(style, options.styles[style]);
  }

  this.resetAxisOptions(options.axis);
  return this;
}

; //************************************************************************************************************
// Basic Functions
//************************************************************************************************************

simple_graph_SimpleGraph.prototype.getSvgElement = function () {
  return this.svg;
};

simple_graph_SimpleGraph.prototype.getSvgGraphic = function () {
  return this.svgGraph;
};

simple_graph_SimpleGraph.prototype.remove = function () {
  this.svg.remove();
  return this;
};

simple_graph_SimpleGraph.prototype.destroy = function () {
  this.svg.remove();
  this.svg = null;
  this.svgGraph = null;
  this.clearAllData();
  this.color = null;
  this.customColors = null;
  this.x = null;
  this.y = null;
  this.minMax = null;
  this.xScale = null;
  this.yScale = null;
  this.yAxis = null;
  this.xAxis = null;
  this.yGridAxis = null;
  this.xGridAxis = null;
  this.points = null;
  this.ptSeriesShapes = null;
  this.lines = null;
  this.pointLines = null;
  this.areas = null;
}; //************************************************************************************************************
// Add modules
//************************************************************************************************************
// Axis functions



sg_axis(simple_graph_SimpleGraph, external_amd_d3_root_d3_commonjs_d3_commonjs2_d3_); // Color/category functions


sg_color(simple_graph_SimpleGraph, external_amd_d3_root_d3_commonjs_d3_commonjs2_d3_); // Grid and legend


sg_grid_legend(simple_graph_SimpleGraph, external_amd_d3_root_d3_commonjs_d3_commonjs2_d3_); // Data functions




sg_data_point(simple_graph_SimpleGraph, external_amd_d3_root_d3_commonjs_d3_commonjs2_d3_);
sg_data_area(simple_graph_SimpleGraph, external_amd_d3_root_d3_commonjs_d3_commonjs2_d3_);
sg_data_line(simple_graph_SimpleGraph, external_amd_d3_root_d3_commonjs_d3_commonjs2_d3_); // Draw functions





sg_draw_lib(simple_graph_SimpleGraph, external_amd_d3_root_d3_commonjs_d3_commonjs2_d3_);
sg_draw_points(simple_graph_SimpleGraph, external_amd_d3_root_d3_commonjs_d3_commonjs2_d3_);
sg_draw_lines(simple_graph_SimpleGraph, external_amd_d3_root_d3_commonjs_d3_commonjs2_d3_);
sg_draw_areas(simple_graph_SimpleGraph, external_amd_d3_root_d3_commonjs_d3_commonjs2_d3_); // Interactivity functions



sg_tooltip(simple_graph_SimpleGraph, external_amd_d3_root_d3_commonjs_d3_commonjs2_d3_);
sg_highlight(simple_graph_SimpleGraph, external_amd_d3_root_d3_commonjs_d3_commonjs2_d3_); //************************************************************************************************************
// Misc Functions
//************************************************************************************************************

simple_graph_SimpleGraph.prototype.clearAllData = function (series) {
  this.clearPointsData(series);
  this.clearLinesData(series);
  this.clearAreasData(series);
  return this;
};

simple_graph_SimpleGraph.prototype.removeAll = function () {
  this.removePoints().removeAllLines().removeAreas();
  return this;
};

simple_graph_SimpleGraph.prototype.saveAsPng = function (pngName) {
  if (!pngName) {
    pngName = "graph.png";
  }

  if (!pngName.toLowerCase().endsWith(".png")) {
    pngName += ".png";
  }

  var svgNode = this.svg.attr("version", "1.1").attr("xmlns", "http://www.w3.org/2000/svg").attr("xmlns:xlink", "http://www.w3.org/1999/xlink").node();
  var serializer = new XMLSerializer();
  var svgHtml = serializer.serializeToString(svgNode);
  var canvas = document.createElement("canvas");
  canvas.style.display = "none";
  canvas.width = this.containerWidth;
  canvas.height = this.containerHeight; // because internet explorer, this is only way around the security error (requires canvg library which is 
  // not explicitly required, assumed loaded somewhere on the page globally)

  if (navigator.msSaveBlob && canvg) {
    // have to manually replace the width/height in cases of bottom-buffer IE hack for resizable graphs
    svgHtml = svgHtml.replace("style=\"width: 100%; height: 1px;", "style=\"width:" + this.containerWidth + "px; height:" + this.containerHeight + "px;"); // draw via canvg, which is totally redudant if not for the fact this is only way to bypass security error

    canvg(canvas, svgHtml);
    navigator.msSaveBlob(new Blob([canvas.msToBlob()], {
      type: "image/png"
    }), pngName);
    return this;
  }

  var a = document.createElement("a");
  a.style.display = "none";
  a.download = pngName;
  this.svg.node().parentNode.appendChild(a);
  var img = new Image();

  img.onload = function () {
    canvas.getContext("2d").drawImage(img, 0, 0); // freaking internet explorer..

    if (navigator.msSaveBlob) {
      try {
        navigator.msSaveBlob(new Blob([canvas.msToBlob()], {
          type: "image/png"
        }), pngName);
      } catch (e) {
        // still doesn't work because of overly strict security restrictions in IE
        alert("Sorry, SVG to PNG downloads are restricted in Internet Explorer, please try with another browser.");
      }
    } else {
      a.href = canvas.toDataURL("image/png");
      a.click();
    }

    a.parentElement.removeChild(a);
    canvas.remove();
  };

  img.src = "data:image/svg+xml;base64," + btoa(unescape(encodeURIComponent(svgHtml)));
};

/* harmony default export */ var simple_graph = (simple_graph_SimpleGraph);
// CONCATENATED MODULE: ./src/entry.js


/* harmony default export */ var entry = __webpack_exports__["default"] = (simple_graph);

/***/ })
/******/ ])["default"];
});